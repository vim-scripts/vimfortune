This file comes from the Vim Online tip database.  
These tips were downloaded on Sat, 11 May 2002 13:39:05 -0700
More tips can be found at http://vim.sf.net/tips
A new tip file can be downloaded from http://vim.sf.net/tips/download.php
%
When a discussion started about learning vim on the vim list Juergen Salk
mentioned the "*" key as something that he wished he had know earlier. When I
read the mail I had to go help on what the heck the "*" did. I also wish I had
known earlier...

Using the "*" key while in normal mode searches for the word under the cursor.

If that doesn't save you a lot of typing, I don't know what will.
%
It was often frustrating when I would open a file deep in the code tree and
then realize I wanted to open another file in that same directory. Douglas
Potts taught me a nice way to do this. Add the following snipit to your vimrc:

"   Edit another file in the same directory as the current file
"   uses expression to extract path from current file's path
"  (thanks Douglas Potts)
if has("unix")
    map ,e :e <C-R>=expand("%:p:h") . "/" <CR>
else
    map ,e :e <C-R>=expand("%:p:h") . "\" <CR>
endif

Then when you type ,e in normal mode you can use tab to complete to the file.
You can also expand this to allow for spitting, etc. Very very nice.
%
For a number of years I used vim on an SGI box. When I left my job at SGI I
went to a company that developed on PCs. For 2 years I used IDEs. I was
unhappy. I was frustrated. I couldn't figure out why. (Beyond my machine
crashing twice a day.) Finally I upgraded to windows 2000 (kind of stable!) and
started using vim as an IDE. All was good. Here is how you use vim to compile
your java:

1. While I'm sure this works with javac, javac is slow slow slow. So download
the Jikes complier first. (Jikes is from ibm, search on google for jikes and
you will find it..available on most platforms.)

2. Add the following to your vimrc:

set makeprg=jikes -nowarn -Xstdout +E %
set errorformat=%f:%l:%c:%*\d:%*\d:%*\s%m 

3. When you are editing a java file type :make and it will compile the current
file and jump you to the first error in the file (if any). Read ":help
quickfix" for how to move between errors.

To setup your classpath environment either launch gvim from a shell that has
your classpath/path setup or use the "let" command to configure it in your
vimrc.
%
Either when programming or writing, I tend to have some identifiers or words
that I use all the time. By sheer accident, I noticed the 'ctrl-n' command,
that will attempt to complete the word under the cursor. Hit it once, and it
will try to complete it with the first match in the current file. If there is
no match, it will (at least in the case of C code) search through all files
included from the current one. Repeated invocations will cycle through all
found matches.
%
To search for a word under the cursor in the current file you
can use either the "*" or "#" keys.

The "*" key will search for the word from the current cursor 
position to the end of the file. The "#" key will search for the 
word from the current cursor position to the top of the file.

Note that the above two keys will search for the whole word and not
the partial word.  This is equivalent to using the <word> pattern
in the search commands (/ and ?).

To search for partial matches, you can use the "g*" and "g#" key
sequence.

You can also use the mouse to search for a word.  This will only
work in the GUI version of VIM (gvim) or a console version
of VIM in an xterm which accepts a mouse. Also, the 'mousemodel'
should be set to 'extend'.  Add the following line to your .vimrc:

set mousemodel=extend

To search for a word under the cursor from the current cursor
position to the end of the file, press the shift key and click
on the word using the left mouse button.  To search in the opposite
direction, press the shift key and click on the word using the
the right mouse button.

To get more help on these, use

:help *
:help #
:help g*
:help g#
:help <S-LeftMouse>
:help <S-RightMouse>
%
The % key can be used

1. To jump to a matching opening or closing parenthesis, square 
   bracket or a curly brace i.e. ([{}])
2. To jump to start or end of a C-style comment /* */.  
3. To jump to a matching #if, #ifdef, #else, #elif, #endif C 
   preprocessor conditionals.

To get more information about this, do

             :help %

The % key can be extended to support other matching pairs by
modifying the "matchpairs" option.  Read the help on

             :help matchpairs
%
To jump to the beginning of a C code block (while, switch, if etc),
use the [{ command.

To jump to the end of a C code block (while, switch, if etc),
use the ]} command.

The above two commands will work from anywhere inside the code
block.

To jump to the beginning of a parenthesis use the [( command.

To jump to the end of a parenthesis use the ]) command.

To get more help on these commands, do

:help [{
:help ]}
:help [(
:help ])
%
'gd' command: 
To jump to the declaration of a local variable in a C program, 
position the cursor on the name of the variable and use the
gd command.

'gD' command:
To jump to the declaration of a global variable in a C program, 
position the cursor on the name of the variable and use the
gD command.
%
To display the definition of a variable, place the cursor on the
variable and use the [i command.  To display a macro definition,
place the cursor on the macro name and use the [d command.
Note that these commands will work most of the time (not all the
time).  To get more help on these commands, use

:help [i
:help [d
%
Vim remembers all the locations visited by you in a file in a session.
You can jump to the older locations by pressing the Ctrl-O key.  You
can jump to the newer locations by pressing the Ctrl-I or the <Tab>
key.

To get more help on these keys, use

:help CTRL-O
:help CTRL-I
:help jump-motions


In Insert mode, press the Ctrl-p or Ctrl-n key to complete part of 
a word that has been typed.

This is useful while typing C programs to complete long variable and
function names.  This also helps in avoiding typing mistakes.

Note that using the 'complete' option, you can complete keywords
defined in one of the include files, tag file, etc.

To get more help on this, use

:help i_Ctrl-N
:help i_Ctrl-P
:help ins-completion
:help complete
%
To insert space characters whenever the tab key is pressed, set the
'expandtab' option:

        set expandtab

With this option set, if you want to enter a real tab character use
Ctrl-V<Tab> key sequence.

To control the number of space characters that will be inserted when
the tab key is pressed, set the 'tabstop' option.  For example, to
insert 4 spaces for a tab, use:

        set tabstop=4

After the 'expandtab' option is set, all the new tab characters entered
will be changed to spaces.  This will not affect the existing tab
characters.  To change all the existing tab characters to match the
current tab settings, use

        :retab

To change the number of space characters inserted for indentation, use
the 'shiftwidth' option:

        set shiftwidth=4

For example, to get the following coding style,
        - No tabs in the source file
        - All tab characters are 4 space characters

use the following set of options:

        set tabstop=4
        set shiftwidth=4
        set expandtab

Add the above settings to your .vimrc file.

To get more help on these options, use
:help tabstop
:help shiftwidth
:help expandtab
%
To move the cursor to the matched string, while typing the search
string, set the following option in the .vimrc file:

        set incsearch

You can complete the search by pressing the Enter key.  To cancel
the search, press the escape key.
%
To highlight all the search pattern matches in a file set the
following option:

        :set hlsearch

After this option is set, if you search for a pattern, all the
matches in the file will be highlighted in yellow.

To disable the highlighting temporarily, use the command

        :nohlsearch

This command will remove the highlighting for the current search.
The highlighting will come back for the next search.

To disable the highlighting completely, set the following option:

        :set nohlsearch

By default, the hlsearch option is turned off.

To get more help on this option, use

:help 'hlsearch'
:help :nohlsearch
%
To display the status line always, set the following option in
your .vimrc file:

        set laststatus=2

The advantage of having the status line displayed always is, you
can see the current mode, file name, file status, ruler, etc.

To get more help on this, use

:help laststatus
%
To avoid the "Hit ENTER to continue" prompt, use the 'shortmess'
option.  Add the following line to your .vimrc file:

    set shortmess=a

Also, you can increase the height of the command line to 2

    set cmdheight=2

The default command height is 1.

To get more help on these options, use

:help hit-enter
:help shortmess
:help cmdheight
%
In insert mode, to erase previously entered characters, set the
following option:

        set backspace=2

By default, this option is empty.  If this option is empty, in
insert mode, you can not erase characters entered before this
insert mode started.  This is the standard Vi behavior.

To get more help on this, use

:help 'backspace'
%
From Johannes Zellner on the vim list:

You can use vim's makeprg and equalprg to clean up HTML. First download html
tidy from http://www.w3.org/People/Raggett/tidy/. Then use the following
commands.

vim6?
exe 'setlocal equalprg=tidy -quiet -f '.&errorfile
setlocal makeprg=tidy -quiet -e %

vim5?
exe 'set equalprg=tidy -quiet -f '.&errorfile
set makeprg=tidy -quiet -e %

At this point you can use make to clean up the full file or you can use = to
clean up sections.

:help =
:help equalprg
:help makeprg
%
I have started doing all my code reviews on a laptop because of the number command.

:set number will put line numbers along the left side of a window

:help number
%
Have you ever been frustrated at swap files and backups cluttering
up your working directory? 

Untidy:
  ons.txt
  ons.txt~
  README
  README~
  tester.py
  tester.py~

Here are a couple of options that can help:

  set   backupdir=./.backup,.,/tmp
  set   directory=.,./.backup,/tmp

This way, if you want your backups to be neatly grouped, just 
create a directory called '.backup' in your working directory. 
Vim will stash backups there. The 'directory' option controls
where swap files go. If your working directory is not writable,
Vim will put the swap file in one of the specified places.
%
In Vim, the unnamed register is the " register, and the Windows
Clipboard is the * register. This means that if you yank something,
you have to yank it to the * register if you want to paste it into
a Windows app. If this is too much trouble, set the 'clipboard' 
option to 'unnamed'. Then you always yank to *.

So pasting to windows apps doesn't require prefixing "* :

  set   clipboard=unnamed
%
I frequently hold the shift key for too long when typing, for instance :wq, and
end up with :Wq.  Vim then whines "Not an editor command: Wq"

In my .vimrc, I have taught vim my common typos:
command! Q  quit
command! W  write
command! Wq wq
" this one won't work, because :X is already a built-in command
command! X  xit
%
Check out your .vimrc. If 'set notitle' is an entry, comment it out with a
quotation mark ("). Now your xterm should inherit the title from Vim.
e.g. 'Vim - ~/.vimrc'. This can be quite nice when programming and editing lots
of files at the same time.
by [jonasbn@wanadoo.dk]
%
	 Here are some pointers to the vim documentation.  Notice that the
	 mechanism is different in vim 6.0 and vim 5.x.

1. I want *.foo files to be highlighted like HTML files.

:help new-filetype  http://www.vim.org/html/autocmd.html#new-filetype

2. I want to define a syntax file for *.bar files.  Read the above and also

:help mysyntaxfile  http://www.vim.org/html/syntax.html#mysyntaxfile

3. I want to make a few changes to the existing syntax highlighting.  Depending
on the x in 5.x, either read the above and page down a few screens, or you may
be able to skip right to

:help mysyntaxfile-add  http://www.vim.org/html/syntax.html#mysyntaxfile-add

4. I want to change some of the colors from their defaults.  Again, read

:help mysyntaxfile  http://www.vim.org/html/syntax.html#mysyntaxfile
%
The following settings in .vimrc will enable color highlighting when using
SecureCRT and may work on other telnet packages. The terminal type should be
selected as ANSI and color enabled.


if !has("gui_running")
set t_Co=8
set t_Sf=^[[3%p1%dm
set t_Sb=^[[4%p1%dm
endif


The ^[ is entered as "<ctrl-v><esc>" 
%
If you work in a mixed environment you will often open files that have ^M's in
them. An example would be this:

------------------------------------------------------------------
import java.util.Hashtable; ^M
import java.util.Properties; ^Mimport java.io.IOException;
import org.xml.sax.AttributeList; ^M
import org.xml.sax.HandlerBase; ^Mimport org.xml.sax.SAXException;

/**^M
  * XMLHandler: This class parses the elements contained^M
  * within a XML message and builds a Hashtable^M

[snip]
------------------------------------------------------------------

Notice that some programs are not consistent in the way they insert the line
breaks so you end up with some lines that have both a carrage return and a ^M
and some lines that have a ^M and no carrage return (and so blend into one).
There are two steps to clean this up.

1. replace all extraneous ^M:

:%s/^M$//g

BE SURE YOU MAKE the ^M USING "CTRL-V CTRL-M" NOT BY TYPING "CARROT M"! This
expression will replace all the ^M's that have carriage returns after them with
nothing. (The dollar ties the search to the end of a line)

2. replace all ^M's that need to have carriage returns:

:%s/^M//g

Once again: BE SURE YOU MAKE the ^M USING "CTRL-V CTRL-M" NOT BY TYPING "CARROT
M"! This expression will replace all the ^M's that didn't have carriage returns
after them with a carriage return.

Voila! Clean file. Map this to something if you do it frequently.

:help ffs - for more info on file formats

thanks to jonathan merz, douglas potts, and benji fisher
%
when you check the output of objdump, you'll confused by the $0xFFFFFFc
operand, this function translate the hexcamal to decimal.
function! Hex2Dec()
    let lstr = getline(".")
    let hexstr = matchstr(lstr, '0x[a-f0-9]+')
    while hexstr != ""
        let hexstr = hexstr + 0
        exe 's#0x[a-f0-9]+#'.hexstr."#"
        let lstr = substitute(lstr, '0x[a-f0-9]+', hexstr, "")
        let hexstr = matchstr(lstr, '0x[a-f0-9]+')
    endwhile
endfunction
usage:
5,8call Hex2Dec()
%
With Unix-like environment, you can use cat or awk to generate a line number
easily, because vim has a friendly interface with shell, so everything work in
vim as well as it does in shell.
:%!call -n
or
:%!awk '{print NR,$0}'

But, if you use vim in MS-DOS, of win9x, win2000, you loss these tookit.
here is a very simple way to archive this only by vim:
fu! LineIt()
  exe ":s/^/".line(".")."/"
endf

Well, a sequence composed with alphabet is as easy as above:
  exe "s/^/".nr2char(line("."))."/"
%
:g/^/m0
well, 
1. : bring you to command-line mode(also known as ex-mode) from
normal-mode(also known as command mode).
2. g means you'll take an action through the whole file, generally perform a
search, `v' also perform a search but it match the line not match the canonical
expression.
3. / begins the regular express
4. ^ is a special character respect the start of a line.
5. the second / ends the regular express and indicate that the remains is
action to do.
6. m means move, `t` and `co' for copy, `d' for delete
7. 0 is the destination line.

you can use 
:g/regexp/t$
to filter all lines and pick the match line together and copy them to the end
of the buffer or
:g/regexp/y A
to put them into a register(not eax, ebx...)
%
To increase a number under or nearest to the right of the cursor, go to Normal
mode and type:
    Ctrl-A

To decrease, type:
    Ctrl-X

Using this in a macro simplifies generating number sequences a lot.
%
To find and replace one or more occurences of a given text pattern with a
new text string, use the s[ubstitute] command.

There are a variety of options, but these are what you most probably want:

:%s/foo/bar/g           find each occurance of 'foo' and replace it with 'bar'
without asking for confirmation

:%s/foo/bar/gc          find each occurance of 'foo' and replace it with 'bar'
asking for confirmation first

:%s/<foo>/bar/gc      find (match exact word only) and replace each occurance
of 'foo' with 'bar'

:%s/foo/bar/gci         find (case insensitive) and replace each occurance of
'foo' with 'bar'

:%s/foo/bar/gcI         find (case sensitive) and replace each occurance of
'foo' with 'bar'


NB: Without the 'g' flag, replacement occurs only for the first occurrence in
each line.

For a full description and some more interesting examples of the substitute
command refer to

:help substitute

See also:

:help cmdline-ranges
:help pattern
:help gdefault
%
compare to C and shell(bash), herein is some vim specifics about vim-script:
1. A function name must be capitalized.
   hex2dec is invalid
   Hex2dec is valid
   while in c and shell(bash), both lowercase and uppercase is allowed.
2. how to reference the parameters
   fu! Hex2dec(var1, var2)
    let str=a:var1
    let str2=a:var2
   you must prefix the parameter name with "a:", and a:var1 itself is read-only
   in c, you reference the parameter directly and the parameter is writable.
3. how to implement variable parameter
   fu! Hex2dec(fixpara, ...)
	 a:0 is the real number of the variable parameter when you invoke the
	 function, with :Hex2dec("asdf", 4,5,6), a:0=3, and a:1=4 a:2=5 a:3=6
   you can combine "a:" and the number to get the value
   while i<a:0
     exe "let num=a:".i
     let i=i+1
   endwhile
   in c, the function get the real number by checking the additional parameter
   such as printf family, or by checking the special value such as NULL
4. where is the vim-library
  yes, vim has its own function-library, just like *.a in c
  :help functions
5. can I use += or ++ operator?
  Nop, += and ++ (and -=, -- and so on)operator gone away in vim.
6. How can I assign a value to a variables and fetch its value?
   let var_Name=value
   let var1=var2
   like it does in c, except you must use let keyword
7. Can I use any ex-mode command in a function?
  As I know, yes, just use it directly, as if every line you type appears in
  the familar : 
8. Can I call a function recurse?
  Yes, but use it carefully to avoid infinte call.
9. Can I call another function in a function?
  Course, like C does.
10. Must I compile the function?
   No, you needn't and you can't, just :so script_name, after this you can call
   the function freely.
11. Is it has integer and char or float data type?
   No, like perl, vim script justify the variable type depend upon the context
   :let a=1
   :let a=a."asdf"
   :echo a
   you'll get `1asdf'
   :let a=1
   :let a=a+2
   :echo a
   you'll get 3
   But it differs from perl.
12. Must I append a `;' in every statement?
   No, never do that.
   ; is required in C, and optional in shell for each statement in a alone line.
   But is forbidden in vim.
   if you want combine servals statement in one single line, use `|'.
   Take your mind that every statement appears in function should be valid in
   ex-mode(except for some special statement).
%
I like the line-number for myself editing. But I hate it in on-line help page
because it force the screen wrapped.
:au filetype help :se nonu
%
:se splitbelow 
make the new window appears below the current window.
:se splitright
make the new window appears in right.(only 6.0 version can do a vsplit)
%
the `|' concatenate servals ex-command in one line.
It's the key to translate // style comments to /* */ style
:g#^s{-}//#s##/*# | s#$#*/#

the `|' keep the current line matchs ^s{-}// to perform s#$#*/

/* ... */ ---> //style
:g#/*(.{-})*/#//1#

/* ....
   ....
   .....
*/ 
=====> 
//......
//......
//......
style:
? Anyone implement it?
%
K in normal bring you the man page about the keyword under current cursor.
:nnoremap <F1> :exe ":!info ".expand("<cword>")
Now press F1 while the cursor is hold by a keyword such as printf will bring
you to Gnu-info help page
:h <F1>
:h nnoremap
%
:set number
switch the number on
:set nonumber
switch it off
:set invnumber 
or 
:set number!
switch it inverse against the current setting
:set number&
get the default value vim assums.

replace number with any legal vim-boolean optionals, they all works well.
for vim-non-boolean optionals
:set optional& 
also works properly.
%
If your tierd of the cursor jumping past 5 lines when :set wrap then add these
mappings to you vimrc file.

nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
nnoremap <Down> gj
nnoremap <Up> gk
vnoremap <Down> gj
vnoremap <Up> gk
inoremap <Down> <C-o>gj
inoremap <Up> <C-o>gk

What they do is remap the cursor keys to use there `g' equvilant. See :help gj
%
To undo recent changes, use the u[ndo] command:

u              undo last change (can be repeated to undo preceding commands)
U              return the line to its original state (undo all changes in
current line)
CTRL-R         Redo changes which were undone (undo the undo's).

For a full description of the undo/redo commands refer to

:help undo
%
To insert the contents of a file (or the output of a system command) 
into the current buffer, use the r[ead] command:

Examples:

:r foo.txt        inserts the file foo.txt below the cursor

:0r foo.txt       inserts the file foo.txt above the first line

:r !ls            inserts a listing of your directory below the cursor

:$r !pwd          inserts the current working directory below the last line 


For more information about the r[ead] command refer to:

:help read

See also:

:help cmdline-ranges
:help !cmd
%
	First of all, thanks Benji fisher,  Stefan Roemer...
and others in vim@vim.org which spend much time to 
answer questions, sometimes foolish question asked by
someone like me. Without their I can't get the final 
solution for my sqlplus work descripted follows.
	As Oracle user known, sqlplus has a very bad 
command-line edition environment. It has no 
command-history, don't support most of getline 
facilities. which MySQL and shell does it well. 
Even Microsoft recogonize this point. In Windows2000, 
doskey is installed by default.
	Below is my vim-solution to sqlplus, which 
record the command-history when you use 
edit(sqlplus builtin command) to open the editor
specified by EDITOR environment variable. It saves
the SQL statement into a standalone file such as
.sqlplus.history
	Every time you open the file 
afiedt.buf(sqlplus's default command-buffer file), 
you get two splited windows, the buffer above is 
afiedt.buf, the buffer below is .sqlplus.history, 
you can see every SQL statement in the windows. 
If you want to use SQL statement in line 5 to replace
 the current command-buffer, just press 5K, then 
	:xa
	to back to you sqlplus. and use / to repeat the command
 saved in command-buffer file called afiedt.buf by default.
	It can't process multi-line SQL statement convinencely.
 Todo this, just use you favorite vim trick to do that:
	fu! VimSQL()
    nnoremap <C-K> :<C-U>
	exe "let linenum=".v:count<CR>:1,$-1d<CR><C-W>j:exe lin
	enum."y"<CR><C-W>kP
    let linenum=line("$")
    1,$-1w! >> ~/.sqlplus.history
    e ~/.sqlplus.history
    execute ":$-".(linenum-1).",$m0"
    %!uniq
    if line("$")>100
      101,$d
    endif
    b#
    set splitbelow
    sp ~/.sqlplus.history
    au! BufEnter afiedt.buf
endf
au BufEnter afiedt.buf call VimSQL()
%
To mark one or more positions in a file, use the m[ark] command.

Examples:

ma       -    set current cursor location as mark a

'a       -    jump to beginning of line of mark a

`a       -    jump to postition of mark a

d'a      -    delete from current line to line of mark a

d`a      -    delete from current cursor position to mark a

c'a      -    change text from current line to line of mark a

y`a      -    yank text to unnamed buffer from cursor to mark a

:marks   -    list all the current marks

NB: Lowercase marks (a-z) are valid within one file. Uppercase marks
(A-Z), also called file marks, are valid between files.

For a detailed description of the m[ark] command refer to

:help mark

See also:

:help various-motions 
%
To define abbreviations, use the ab[breviate] command.

Examples:

:ab rtfm read the fine manual  -  Whenever you type 'rtfm' followed by a
<space> (or <esc> or <cr>) vim
                                  will expand this to 'read the fine manual'.

:ab                            -  list all defined abbreviations

:una[bbreviate] rtfm           -  remove 'rtfm' from the list of abbreviations

:abc[lear]                     -  remove all abbreviations


NB: To avoid expansion in insert mode, type CTRL-V after the last character of
the abbreviation. 

For a detailed description of the ab[breviate] command and some more examples
refer to

:help abbreviations
%
Simple text changes in normal mode (e.g. "dw" or "J") can be repeated with the
"." command.
The last command-line change (those invoked with ":", e.g. ":s/foo/bar") can be 
repeated with the "@:" command.

For more informations about repeating single changes refer to:

:help single-repeat
%
You can recall previous command lines from a history table by hitting 
the <Up> and <Down> cursor keys in command-line mode. 
For example, this can be used to find the previous substitute command: 
Type ":s" and then <Up>.

There are separate history tables for the ':' commands and for 
previous '/' or '?' search strings.

To display the history of last entered commands or search strings, 
use the :his[tory] command:

:his       -      Display command-line history. 

:his s     -      Display search string history.

  
For a detailed description of the command-line history refer to:

:help cmdline-history

See also:

:help Cmdline-mode
%
> Does anyone know if windows binaries of vim 5.7 are available with perl and
> python support turned on?

ftp://vim.sourceforge.net/pub/vim/upload_binaries/

http://vim.sourceforge.net/bin_download/
%
To swap two characters or lines, use the following commands:

xp       -     delete the character under the cursor and put it afterwards.
               (In other words, it swaps the characters.)

ddp      -     delete the current line and put it afterwards.
               (In other words, it swaps the lines.)

Unfortunately there is no universal solution to swap two words.
You may try the following ones, but don't expect too much of them:

dawwP    -     delete the word under the cursor, move forward one word
               and put it back after the cursor.  (In other words, it 
               swaps the current and following word.)
               
dawbP    -     delete the word under the cursor, move backward on word
               and put it back after the cursor.  (In other words, it
               swaps the current and preceeding word.)
%
You can save a lot of time when navigating through the text by using 
appropriate movements commands. In most cases the cursor keys,
<PageUp> or <PageDown> are NOT the best choice.

Here is a selection of some basic movement commands that 
hopefully helps you to acquire a taste for more:

e   - move to the end of a word                   
w   - move forward to the beginning of a word     
3w  - move forward three words
b   - move backward to the beginning of a word
3b  - move backward three words

$       - move to the end of the line          
<End>   - same as $
0       - move to the beginning of the line
<Home>  - same as 0

)   - jump forward one sentence
(   - jump backward one sentence

}   - jump forward one paragraph
{   - jump backward one paragraph

H   - jump to the top of the display       
M   - jump to the middle of the display   
L   - jump to the bottom of the display

'm  - jump to the beginning of the line of mark m
`m  - jump to the location of mark m

G   - jump to end of file
1G  - jump to beginning of file
50G - jump to line 50

'' - return to the line where the cursor was before the latest jump
`` - return to the cursor position before the latest jump (undo the jump).

 %  - jump to corresponding item, e.g. from an open brace to its 
     matching closing brace
   
For some more interesting movement commands (especially those 
for programmers) refer to:

:help motion.txt

:help search-commands
%
To switch the case of one or more characters use the "~", "gU" or
"gu" commands.

Examples:

~     -     switch case of character under cursor 
            (in visual-mode: switch case of highlighted text)

3~    -     switch case of next three characters

g~~   -     switch case of current line

U     -     in visual-mode: make highlighted text uppercase

gUU   -     make current line uppercase

u     -     in visual-mode: make highlighted text lowercase

guu   -     make current line lowercase

gUaw  -     make current word uppercase

guaw  -     make current word lowercase

For some more examples refer to

:help ~

See also:

:help simple-change
%
If your computer has crashed while editing a file, you should be able 
to recover the file by typing 

      vi -r <filename>

where <filename> is the name of the file you were editing at the time 
of the crash.
If you were editing without a file name, give an empty string as argument:

      vim -r ""

To get a list of recoverable files start vim without arguments:

      vim -r


For more information about file recovery refer to:

:help recovery
%
To enter german umlauts (or any other of those weired 
characters) not available on your keyboard use 'digraphs':

In insert-mode type for example:
    
     CTRL-K "a

     CTRL-K ^e
 
which gives an 'ä' and 'e' with a hat. 

You can also set the digraph option:

    :set digraph (or :set dg)

With digraph option set you can enter 

    " <BS> a

    ^ <BS> e

which gives the same result.

To get a list of currently defined digraphs type

   :dig[graphs]

For more information about defining and using digraphs refer to:

:help digraph.txt
%
If you want to bind two or more windows such that when one
window is scrolled, the other windows are scrolled simultaneously,
set the 'scrollbind' option for these windows:

:set scrollbind

When a window that has 'scrollbind' set is scrolled, all other
'scrollbind' windows are scrolled the same amount, if possible.

For more information about the 'scrollbind' option refer to

:help scoll-binding
%
For syntax highlighting there are two sets of default color 
maps: One for a light and another one for a dark background.
If you have a black background, use the following command to
get a better color map for syntax highlighting:

:set background=dark

You have to switch off and on again syntax highlighting to
activate the new color map:

:syntax off
:syntax on

For a detailled description of syntax highlighting refer to

:help syntax.txt

See also the Vim syntax support file: $VIMRUNTIME/syntax/synload.vim
%
Hi All,
Wish u could view a Java Class File using Vim,
Well ur query ends here.
First of all u will need a Java Decompiler to decompile
the Class File.
I would suggest the JAD decompiler by Pavel Kouznetsov 
http://www.geocities.com/SiliconValley/Bridge/8617/jad.html

Its a command line decompiler and absolutely free.
U can use any command line decompiler of ur choice.

Next create a vimscript file called jad.vim as
######################### FILE START ################
augr class
au!
au bufreadpost,filereadpost *.class %!d:jad.exe -noctor -ff -i -p %
au bufreadpost,filereadpost *.class set readonly
au bufreadpost,filereadpost *.class set ft=java
au bufreadpost,filereadpost *.class normal gg=G
au bufreadpost,filereadpost *.class set nomodified
augr END
######################## FILE END #####################

Note:- Keep the Jad.exe in a directory with out white spaces.
The -p options directs JAD to send the output to standard output
instead of a .jad file. Other options are described on the JAD site.

Next add the following line in the .vimrc file.
so jad.vim

Next time u do vim abc.class. Viola u have the source code
for abc.class.

NOTE:- I have written the script so as to open the class file
read only, So that u dont accidently modify it.
U can also exted this script to unjar a jar file and then view each
file in the JAR file.
thanks
bhaskar
Any suggestions are welcome
%
One of the keys to vim is buffer management. If I have to use another IDE that
makes me click on a tab every time I want to look at another file I'm going to
go postal.

So of course you know about :ls which lists all the current open buffers. This
gets a little unweildly once you have a full project open so you can also use
:b <any snipit of text> <tab> to complete to an open buffer. This is really
nice because you can type any fragment of a file name and it will complete to
the matching file. (i.e. RequestManager.java can be completed using "tma"<tab>
or "req"<tab> or "r.java"<tab>).

Now for awhile I was also using :bn and :bp which jumps you to the next and
previous buffer respectively. I found I was often frustrated because I wanted
:bp to be the previous buffer I was in, not the previous buffer in the list. So
(drum roll) the reason I wrote this tip was because of:

:b#

jump to the previous buffer you were in. Very very handy. The only thing nicer
are tag, but that's a tip for another time.

:help buffers
:help bn
:help bp

If anybody knows where to get help on # in this context please add notes.
%
If you take the time to lay out several windows
with vim (especially vertically in version 6), you may be bummed when
you hit an errant key and find that all but what one window
disappears.

What happens: while navigating between windows, you
hit <C-W>j, <C-W>k, etc.  At some point you accidently
hit <C-W> but then don't follow with a window command.
Now hitting 'o' to start insert mode issues a command
equivalent to :only, and closes all windows execept
for the one you are in (unless some windows have unsaved
changes in them).

How to avoid this: petition the vim-dev mailing list about
how :only is sufficient for the infrequenty use this might
get (j/k).

Really: use mapping to disable the <C-W>o functionality; put
this in your .vimrc:

nnoremap <C-W>O :echo "sucker"<CR>
nnoremap <C-W>o :echo "sucker"<CR>
nnoremap <C-W><C-O> :echo "sucker"<CR>

references:

:help :only
:help CTRL-W_o

That is all.
Scott
%
If you'd like to apply a substitute, or even any ex command, to a visual-block
selected text region (ctrl-v and move), then you'll want Stefan Roemer's
http://www.erols.com/astronaut/vim/vimscript/vis.vim .  Just source it in,
and then press ":B".  On the command line you'll see

:'<,'>BCtrl-V 

Just continue with the substitute or whatever...

:'<,'>B s/abc/ABC/g

and the substitute will be applied to just that block of text!

Example: Ctrl-V Select..........|......Type
..................just the central....|......:B s/abc/ABC/g
..................four "abc"s..............|
..................----------------....|...-------------
..................abcabcabcabc............|......abcabcabcabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcabcabcabc
 (dots inserted to retain tabular format)
%
If you'd like to apply a substitute, or even any ex command, to a visual-block
selected text region (ctrl-v and move), then you'll want Stefan Roemer's
http://www.erols.com/astronaut/vim/vimscript/vis.vim .  Just source it in,
and then press ":B".  On the command line you'll see

:'<,'>BCtrl-V 

Just continue with the substitute or whatever...

:'<,'>B s/abc/ABC/g

and the substitute will be applied to just that block of text!

Example: Ctrl-V Select..........|......Type
..................just the central.......|......:B s/abc/ABC/g
..................four "abc"s.................|
..................---------............|...-------------
..................abcabcabcabc............|......abcabcabcabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcabcabcabc
 (dots inserted to retain tabular format)
%
Sometimes I think it's helpful if your working directory is always the same as
the buffer you are editing.  You need to put this in your .vimrc:

function! CHANGE_CURR_DIR()
	let _dir = expand("%:p:h")
	exec "cd " . _dir
	unlet _dir
endfunction

autocmd BufEnter * call CHANGE_CURR_DIR()

Doing this will make a "cd" command to your the current buffer each time you
switch to it.  This is actually similar to vimtip#2 but more automatic.

You should see for more details:
:help autocmd
:help expand
:help function

Note: This tip was contributed by somebody on the list a while ago (sorry for
no reference) and it has been extremely helpful to me. Thanks!
%
Although :set number will add nice line number for you At time you may wish to
actually place the line numbers into the file. For example on GNU Unix you can
acomplish a simular task using cat -n file > new_file

In VIM you can use the global command to do this

:g/^/exec "s/^/".strpart(line(".")."    ", 0, 4)

What this does is run the exec comand on every line that matches /^/ (All)
The exec command taks a string and executes it as if it were typed in.

line(".")."    " -> returns the number of the current line plus four spaces.
strpart("123    ", 0, 4) -> returns only the first four characters ("123 ").
"s/^/123 " -> substituts the begining of the line with "123 ".
%
This one is a one of my favorites from Dr. Chip, and I haven't seen it come
across vim tips yet...

Can use either visual, or marking to denote the text.

" transfer/read and write one block of text between vim sessions
" Usage:
" `from' session:
"     ma
"     move to end-of-block
"     xw
"
" `to' session:
"     move to where I want block inserted
"     xr
"
if has("unix")
  nmap xr   :r $HOME/.vimxfer<CR>
  nmap xw   :'a,.w! $HOME/.vimxfer<CR>
  vmap xr   c<esc>:r $HOME/.vimxfer<CR>
  vmap xw   :w! $HOME/.vimxfer<CR>
else
  nmap xr   :r c:/.vimxfer<CR>
  nmap xw   :'a,.w! c:/.vimxfer<CR>
  vmap xr   c<esc>:r c:/.vimxfer<cr>
  vmap xw   :w! c:/.vimxfer<CR>
endif
%
Sometimes we, the programmers, need the value of a character, don't we?
You can learn the ascii value of a character by pressing g and a keys.(ga)!
It displays the value in dec, hex and octal...
%
Don't worry if your delete key does not work properly.
Just press <CTRL>-Backspace.
It works under both mode(insert or normal).
%
You can copy and paste the last changes you made in the last insert mode
without using y and p by pressing . (just dot). 
Vim memorizes the keys you pressed and echos them if you hit the dot key. 
You must be in command mode as usual.
It can be helpful...
%
From Peter Bismuti on the vim list:

How to global search and replace in all buffers with one command? 
You need the AllBuffers command:

:call AllBuffers("%s/string1/string2/g")

"put this in a file and source it
function AllBuffers(cmnd)
  let cmnd = a:cmnd
  let i = 1
  while (i <= bufnr("$"))
    if bufexists(i)
      execute "buffer" i
      execute cmnd
    endif
    let i = i+1
  endwhile
endfun

":call AllBuffers("%s/foo/bar/ge|update")

Thanks Peter!
%
If you use gvim, you can transfer text from one instance of gvim into another
one using clipboard.  It is convenient to use * (star) register, like this:

In one instance yank two lines into clipboard:
    "*2yy
Paste it in another instance in normal mode:
    "*p
or in insert mode:
    <Ctrl-R>*
%
Sometimes to improve the readability of the document I insert empty lines,
which will be later removed.
To get rid off them try: 
:%g/^$/d
This will remove a l l  empty line in the document.
Some other tipps you can find under www.linuxclass.de/vim.phtml
%
Basic calculations can done within vim easily by typing (insert-mode):
STRG (=CTRL) + R followed by =
then for example 2+2 and hit RETURN
the result 4 will be printed in the document.

Some other tipps you can find under www.linuxclass.de/vim.phtml
%
With the addition of folding, Vim6 can function as a high performance outline
processor. Simply :set ai and in insert mode use backspace to promote and tab
to demote headlines.

In command mode, << promotes (n<< to promote multiple lines), and >> demotes.
Also, highlight several headlines and < or > to promote or demote.

:set foldmethod=indent, and then your z commands can expand or collapse
headline trees, filewide or by the tree.

The VimOutliner GPL distro contains the scripts and configs to easily configure
Vim6 as an outliner, including scripts to create tag files enabling
interoutline hyperlinking.

The VimOutliner project is at
http://www.troubleshooters.com/projects/vimoutliner/index.htm.

Steve (Litt)
slitt@troubleshooters.com
%
If you're Windows 2000 Professional user and got tired to move your hands off
basic row when hitting <ESC> key
here the solution (not for Windows 9x.):
remap CapsLock key as <ESC> key. It's located in useful position.
Put this lines into <EscLock.reg> file and start it in explorer.Reboot.Enjoy.

REGEDIT4
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,01,00,3a,00,00,00,00,00

To restore you capslock back just delete this entry from Registry and reboot.
And below is remapping <capslock> as <Left Control>:

REGEDIT4
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,1d,00,3a,00,00,00,00,00
%
The Quickfix mode aims to "speed up the edit-compile-edit cycle" according to
':help quickfix'. After executing ':make' or ':grep' it is possible to skim
through the list of errors/matches and the appropriate source code locations
with, for instance, the ':cnext' command.
Another way to get a quick overview is to use VIMs folding mode, to fold away
all the error-free/match-free regions.
The script at the end of this message can be used for this purpose. It is at
the moment not elaborate enough to put it up as a 'script'; but it might give
someone inspiration to do so.
Big restrictions / bugs are as follows:
1. Vim Perl interface is required, i.e. the output of ':version' must contain
'+perl' (People with Vim scripting knowledge might fix this)
2. Works only for one file, i.e. the current buffer.
3. It's a quick hack.
Sample usage: (a) edit a file, (b) do ':grep regexp %' to get a quickfix error
list and (c) ':source foldqf.vim' will fold as described
Increasing the value of $CONTEXT gives you more context around the error regions.

Here comes it, it should be 7 lines:
---foldqf.vim
cwindow
perl $CONTEXT = 0;
perl @A = map { m/\|(\d+)\|/; $1 +0 } $curbuf->Get(1..$curbuf->Count());
close
normal zD
perl sub fold { VIM::DoCommand( $_[0] . ',' . ($_[1]) . "fold" ) if( $_[0] <
$_[1] ); }
perl $last = 0; for (@A) { fold( $last+1+$CONTEXT, $_-1-$CONTEXT ); $last = $_;
}; VIM::DoCommand(($A[-1]+1+$CONTEXT ) . ',$fold' );
%
A guy I work with told me about a function that an old IBM text editor had that
he said was useful, and that is to create folds in the file after a search such
that every line that is visible contains the search pattern(except possibly the
first). All lines that do not contain the search pattern are folded up to the
last occurence of the pattern or the top of the file.  

One use for such a function is to be able to make a quick and dirty api of a
source file.  For example, if working in Java, you could run the function using
the pattern "public|protected|private" and ithe results would be that only the
method headers would be visible (well, close enough).  


function! Foldsearch(search)
        normal zE          "erase all folds to begin with
        normal G$          "move to the end of the file
	let folded = 0     "flag to set when a fold is found
        let flags = "w"    "allow wrapping in the search
        let line1 =  0     "set marker for beginning of fold
        while search(a:search, flags) > 0
                let  line2 = line(".")
		"echo "pattern found at line # " line2
                if (line2 -1 > line1)
                        "echo line1 . ":" . (line2-1)
                        "echo "A fold goes here."
                        execute ":" . line1 . "," . (line2-1) . "fold"
						let folded = 1       "at least one fold has been found
                endif
                let line1 = line2     "update marker
                let flags = "W"       "turn off wrapping
        endwhile
		" Now create the last fold which goes to the end of the file.
        normal $G
        let  line2 = line(".")
		"echo "end of file found at line # " line2
        if (line2  > line1 && folded == 1)
                "echo line1 . ":" . line2
                "echo "A fold goes here."
                execute ":". line1 . "," . line2 . "fold"
        endif
endfunction


" Command is executed as ':Fs pattern'"
command! -nargs=+ -complete=command Fs call Foldsearch(<q-args>)
" View the methods and variables in a java source file."
command! Japi Fs public\|protected\|private
%
VimTip 78: rotating mail signatures
http://vim.sf.net/tips/tip.php?tip_id=78

For people using mutt and vim for mail, the following script will allow you to
insert a new signature (and again and again if you don\'t like the current one)
at the bottom of your mail. This is usefull eg when you don\'t want to send a
potentially offensive quote to someone you don\'t know very well (or a mailing
list), but are too lazy to delete the quote, open your quotes file, and cut and
paste another one in. (I put it here in \'tips\' and not in \'scripts\' because
it is imo too short to be a \'real\' script)

" rotate_sig.vim
" Maintainer:  Roel Vanhout <roel@2e-systems.com>
" Version:     0.1
" Last Change: Tuesday, June 12, 2001
" Mapping I use:
" nmap ,r :call RotateSig()<CR>
" Usage:
" -Make sure you delimit your sig with '-- ', or adjust the script
" -Adjust the last execute to a command that prints a sig to stdout
" Known problems:
"   - You'll get an error message when you're below the last
"     '^-- $' in your mail (nothing bad though - just an not-
"     found marker)

function! RotateSig()
    normal mQG
    execute '?^-- $'
    execute ':nohl'
    normal o<ESC>
    normal dG
    normal <CR>
    execute 'r !~/bin/autosig ~/.quotes \%'
    normal `Q
endfunction
%

The following function will make a :cwindow window with a line per function
in the current C source file. NOTE: It writes the file as a side effect.

Invoke with ':call ShowFunc()'
You may want to do :nmap <somekey> :call ShowFunc()<CR>

function! ShowFunc()
    
    let gf_s = &grepformat
    let gp_s = &grepprg

    let &grepformat = '%*\k%*\sfunction%*\s%l%*\s%f %*\s%m'
    let &grepprg = 'ctags -x --c-types=f --sort=no -o -'

    write
    silent! grep %
    cwindow

    let &grepformat = gf_s
    let &grepprg = gp_s

endfunc
%
Here's something for your <.vimrc> which will allow you to restore your cursor
position in a file over several editing sessions.  This technique uses the
viminfo option:

Ex. set viminfo='10,\"100,:20,%,n~/.viminfo
	au BufReadPost * if line("'\"") > 0|if line("'\"") <= line("$")|exe("norm
	'\"")|else|exe "norm $"|endif|endif

If you're on Unix, the viminfo is probably fine as is (but check up on Vim's
help for viminfo to see if you like the settings above).  For Windows you'll
need to change the "n" suboption to something like

Ex. set viminfo='10,\"100,:20,%,nc:\\some\\place\\under\\Windoz\\_viminfo

This tip is a somewhat improved version of the example given for :he line()
in the Vim on-line documentation.
%
Substitute  Characters
-----------------------------------
I was just editing a file that contained the same leading string on many lines. 

example:

foo_bar_baz1=a
foo_bar_baz1=abc674
foo_bar_baz1=qrs
foo_bar_baz1=m1
foo_bar_baz1=bz90
foo_bar_baz1=bc
...

Needing to only substitute a portion of the string, I referred to a VIM
reference card and discovered a command answering my need exactly. The s
command is used to subsitute a certain number of characters. In my example file
above, if I only needed to subsititute the characters foo_bar, I set the cursor
on the first character where I'd like the subsitution to begin and type 7s. VIM
drops the characters foo_bar and goes to insert mode, waiting for the
substitution text.

Substitute Lines
-----------------------
After years of using vi and VIM and always deleting multiple lines in order to
replace them, I just discovered the S command. If you need to subsitute three
lines of text, simply type 3S. VIM drops the three lines and goes into insert
mode, waiting for the subsitution text. 
%
this is a simple function i wrote to get the value of a variable from three
different places (in that order):  the current buffer, the global setting or
from the script itself.

this allows me to set a default value for a configuration variable inside my
script and the user to change it on a global level by setting the same variable
with a g: prepended.  then, they can further set it on a per-buffer level by
the the b: mechanism.  one of the examples for this might be my comments script
(not uploaded).  i have a variable in there that determines whether comment
characters (// for java, for example) are placed the beginning of the line or
just before the first-non-blanks in the text.  i set up a default in my script:

let s:comments_hug_start_of_line=0   " comments should hug the text

that's fine as a default, but if i want to overwrite it for vim scripts, i just
put the following in my ftplugin/vim.vim:

let b:comments_hug_start_of_line=1   " vim comments should hug the first
column, always

" tries  to return  the buffer-specific  value of  a variable;  if not
" found,  tries to  return the  global value  -- if  that's not  found
" either, returns the value set in the script itself
function! GetVar(varName)
  if (exists ("b:" . a:varName))
    exe "let retVal=b:" . a:varName
  elseif (exists ("g:" . a:varName))
    exe "let retVal=g:" . a:varName
  elseif (exists ("s:" . a:varName))
    exe "let retVal=s:" . a:varName
  else
    retVal=-1
  endif
  return retVal
endfunction

personally, i never let it get to the -1 state by always having an s: set with
SOME default value.
%
Here is the most useful vim command that I know of and I'm surprised that it's
not yet in the tips list.

I use the indent features of vim all the time. Basically, it lets you indent
your source code.

SETUP: To make indentation work nicely I have the following in my .vimrc file:
set et
set sw=4
set smarttab

these make vim behave nicely when indenting, giving 4 spaces (not tabs) for
each "tabstop".

HOW TO USE:
in command mode, == will indent the current line
selecting a range of lines (with shift-v) then == will indent your selection
typing a number then == will indent that many lines, starting from your cursor
(you get the idea, there are many other things you can do to select a range of lines)

Tell me that isn't great?
%
one of the things i do a lot in vim is to make a change to the beginning
or end of  the line (such as adding  the text '// remove' at  the end of
java debug code).  a quick way of doing  this is to use a  to append the
text to the end of the first line  and then move down one, hit . (repeat
last edit), move down, hit .  etc. etc. the following mapping allows one
to  simply  highlight the  region  in  question and  hit  .  -- it  will
automatically execute the . once on each line:

  " allow the . to execute once for each line of a visual selection
  vnoremap . :normal .<CR>

another thing i do a lot is to  record a quick macro in the "a" register
and then play it back a number of  times. while @@ can be used to repeat
the last register used, my recorded macros sometimes use other registers
so @@ doesn't necessarily  give me the same results as  @a. also, i have
mapped ' to `  because i like to go to the precise  location of my marks
-- always --  and never to the  beginning of the line. this  leaves my `
key unused. so:

  " make ` execute the contents of the a register
  nnoremap ` @a

then, in keeping with the visual . above, i did the same for the ` -- is
thexecutes @a once on each highlighed line.

  vnoremap ` :normal @a<CR>

as an example, say i have the following lines of java code:

      public String m_asdf;
      public String m_lkhj;
      public int m_hjkhjkh;

and, for some reason, i need to get the following:

      "asdf"
      "lkhj"
      "hjkhjkh"

i record the following into a:

  ^cf_"<ESC>$r"

the ^  is because my  java code is  indented and i  don't want to  go to
column 0 and the <esc> is an actual escape i hit to exit insert mode.

then, i  simply select (visually) the  other lines (only two  in case --
admittedly not an overly useful example) and just hit `.
%
If you do not have vim 6.0, but would like to mimic the plugins directory
feature then copy and paste this into your vimrc:

exec "source " . substitute(glob($VIM."/plugins/*.vim"), "\n", "\nsource ", "g")

It will automatically source every vim script file located in the vim/plugins
directory.
Now, to add a new plugin, just drop the script in this directory and vim will
automatically find it.
%
When U entered text, U cannot undo only 1 line, for example, when U press "u",
all entered in last "insert" text removed.

If U add this line to .vimrc:
inoremap <Return> <Return>^O^[
where "^O" or "^[" is 1 char
"u" will undo (remove) only 1 line.
%
The format of the window title in vim 5.x (well, at least for 5.7,.8, for
Win32) used to be VIM - <full filename with path>.  It's not in the win32
binary of 6.0an that I found.  I want my old way back.

Turns out, all that it takes to get it back is 
:set title titlestring=VIM\ -\ %F "make sure that the window caption setting is
turned on and set caption to vim 5.x style

Oh, however, one thing I did like about the 6.0 style is that it puts the word
"help" in the title when the current buffer is a help file; so, I just tacked
 %h to my titlestring giving:

:set title titlestring=VIM\ -\ %F\ %h "make sure that the window caption
setting is turned on and set caption to vim 5.x style

see also:
:he 'titlestring'
:he 'statusline'    "for the format for titlestring
%
Maybe it's just because I have far too small of a monitor, because I can get
distracted while coding if I have other stuff on the screen, or because I
starting using vim on a console, but I definitely like my vim window maximized.
Anyway, sticking the following in your vimrc will always maximize your vim
window on startup.

au GUIEnter * simalt ~x


:he win16-maximized
%
I use gvim over console vim because gvim is much more readable (under Windows).
However, that doesn't mean I want to dedicate screen space to things I'll never
use (i.e. the toolbar and the menus).

Anyway, you can give the following a try if you'd like.

set guioptions-=T "get rid of toolbar
set guioptions-=m "get rid of menu

Oh, yeah.  If you decide that you don't really like being without your the
toolbar or menus, issue the following:

set guioptions+=T "bring back toolbar
set guioptions+=m "bring back menu

see also: 
:he 'guioptions
%
You can encrypt your texts by using vim. 
:X  prompts for an encryption key. 
After writing your key, if you save your document 
it will be encrypted and no one else (but you and vim) 
can read your documents.
If you reopen the file, VIM will ask for the key. 
If you want to disable encryption, just type
:set key=
if you forget your key you will lose your document. 
So please DO NOT forget your key,
 
%
This tip will will explain how to use the dictionary completion facilities
provided by vim.  This can be useful if you use vim to type your email, edit
code, etc.  

Dictionary completion is one of many search facilites provided by Insert mode
completion.  It allows the user to get a list of keywords, based off of the
current word at the cursor.  This is useful if you are typing a long word (e.g.
acknowledgeable) and don't want to finish typing or don't remember the
spelling.

To start, we must first tell vim where our dictionary is located.  This is done
via the 'dictionary'  option.  Below is an example.  Your location may vary.
See :help 'dictionary'  for hints as to where you should look.

	:set dictionary-=/usr/share/dict/words dictionary+=/usr/share/dict/words

Now, to use this list we have to enter insert mode completion.  This is done by
hitting CTRL-X while in insert mode.  Next, you have to specify what you want
to complete.  For dictionaries use CTRL-K.  Once in this mode the keys CTRL-N
and CTRL-P will cycle through the matches.  So, to complete the word
"acknowledgeable" I would do the following in insert mode:

	acknow<CTRL-X><CTRL-K><CTRL-N>

It can be cumbersome to type CTRL-X CTRL-K for many different completions.  So,
vim gives us a shortcut.  While in insert mode CTRL-N and CTRL-P will cycle
through a predetermined set of completion sources.  By default, dictionary
completion is not a part of this set.  This set is defined by the 'complete'
option.  Therefore, we must add dictionary to this as shown below:

	:set complete-=k complete+=k

Now, while in insert mode we can type the following to complete our example:

	acknow<CTRL-N><CTRL-N>

This shortcut may not save a whole lot of typing.  However, I find that it
requires less hand movement to only worry myself with two key combinations,
rather than 4.

I find that the completion facilites provided by vim save me a *HUGE* amount of
typing.  These savings can be realized in only a short amount of time if you
are editing some code with functions and variables that have long names with
underscores in them.

For more help:
	help ins-completion
	help compl-dictionary
	help 'complete'
	help 'dictionary'
	help :set+=
%
As everyone knows, the $VIMRUNTIME/doc is increasing rapidly in size. The
directory contained so many plain-text documents that I often compress them to
save my diskspace. With the support of VIM's GZIP plugin, VIM will
automatically uncompress the files when we need to read them.
Here is my procedure:
1.  If you have the source, go to 'runtime/doc' and edit 'doctags.c', change
printf("%s\t%s\t/*", p1, argv[0]);  to  printf("%s\t%s.gz\t/*", p1, argv[0]);
	 then make. This is to modify the tag, or you'll have to change the 'tags'
	 file by hand if you don't have doctags.c.
2. Edit the new generated 'tags' file to rename 'help.txt.gz' back to
'help.txt' because it's hard-written in VIM executable binary.
     :% s/help\.txt\.gz/help\.txt/g
3. Copy the new 'tags' to $VIMRNUTIME/doc and run 'gzip *.txt; gunzip help.txt'

On VIM 6.0an, we can reduce the original size (3302k) to 1326k.
I don't know if this helps, but if someone likes to compress documents... this
can be reffered :)
    
%
It is very convenient to use 'hlsearch' option.  However it can be annoying to
have the highlight stick longer than you want it.  In order to run it off you
have to type at least 4 keystrokes, ":noh".  So, it's a good idea to map this
to a key.  I like to map it to control-n.  This is the line I use in my .vimrc
file to do it:

nmap <silent> <C-N> :silent noh<CR>
%
Using tags file with Vim
------------------------
This document gives you a idea about the various facilities available
in Vim for using a tags file to browse through program source files.
You can read the Vim online help, which explains in detail the tags
support, using :help tagsearch.txt.  You can also use the help
keywords mentioned in this document to read more about a particular
command or option.  To read more about a particular command or option
use, :help <helpkeyword> in Vim.

1. How do I create a tags file?

   You can create a tags file either using the ctags utility or using
   a custom script or utility.

   Help keyword(s): tag

2. Where can I download the tools to generate the tags file?

   There are several utilities available to generate the tags file.
   Depending on the programming language, you can use any one of them.

   1. Exuberant ctags generates tags for the following programming
      language files: 
      
      Assembler, AWK, ASP, BETA, Bourne/Korn/Zsh Shell, C, C++, COBOL,
      Eiffel, Fortran, Java, Lisp, Make, Pascal, Perl, PHP, Python,
      REXX, Ruby, S-Lang, Scheme, Tcl, and Vim.

      You can download exuberant ctags from
      http://ctags.sourceforge.net/

   2. On Unix, you can use the /usr/bin/ctags utility.  This utility
      is present in most of the Unix installations.
   
   3. You can use jtags for generating tags file for java programs.
      You can download jtags from: http://www.fleiner.com/jtags/

   4. You can use ptags for generating tags file for perl programs.
      You can download ptags from:
      http://www.eleves.ens.fr:8080/home/nthiery/Tags/

   5. You can download scripts from the following links for
      generating tags file for verilog files:
   
            http://www.probo.com/vtags.htm
            http://www.cs.albany.edu/~mosh/Perl/veri-tags
            http://www.verilog.net/vrtags.txt

   6. You can download Hdrtag from the following linke:

            http://www.erols.com/astronaut/vim/index.html#Tags

      This utility generates tags file for the following programming
      languages: assembly, c/c++, header files, lex, yacc,LaTeX, vim,
      and Maple V.

   7. You can also use the following scripts which are part of the Vim
      runtime files:

          pltags.pl - Create tags file for perl code
          tcltags - Create tags file for TCL code
          shtags.pl - Create tags file for shell script

   Help keyword(s): ctags

3. How do I generate a tags file using ctags?

   You can generate a tags file for all the C files in the current
   directory using the following command:

        $ ctags *.c

   You can generate tags file for all the files in the current
   directory and all the sub-directories using (this applies only to
   exuberant ctags):

        $ ctags -R .

   You can generate tags file for all the files listed in a text file
   named flist using (this applies only to exuberant ctags)

       $ ctags -L flist

4. How do I configure Vim to locate a tags file?

   You can set the 'tags' option in Vim to specify a particular tags
   file.

        set tags=/my/dir/tags

   Help keyword(s): 'tags', tags-option

5. How do I configure Vim to use multiple tags files?

   The 'tags' option can specify more than one tags file.  The tag
   filenames are separated using either comma or spaces.

        set tags=/my/dir1/tags, /my/dir2/tags

6. How do I configure Vim to locate a tags file in a directory tree?

   Note that the following will work only in Vim 6.0 and above.  You
   can set the 'tags' option to make Vim search for the tags file in a
   directory tree.  For example, if the 'tags' option is set like
   this:

        set tags=tags;/

   Vim will search for the file named 'tags', starting with the
   current directory and then going to the parent directory and then
   recursively to the directory one level above, till it either
   locates the 'tags' file or reaches the root '/' directory.

   Help keyword(s): file-searching

7. How do I jump to a tag?

   There are several ways to jump to a tag location.
        1. You can use the 'tag' ex command.  For example,

               :tag <tagname>
   
           will jump to the tag named <tagname>.
        2. You can position the cursor over a tag name and then press
           Ctrl-].
        3. You can visually select a text and then press Ctrl-] to
           jump to the tag matching the selected text.
        4. You can click on the tag name using the left mouse button,
           while pressing the <Ctrl> key.
        5. You can press the g key and then click on the tag name
           using the left mouse button.
        6. You can use the 'stag' ex command, to open the tag in a new
           window.  For example,

                :stag func1

           will open the func1 definition in a new window.
        7. You can position the cursor over a tag name and then press
           Ctrl-W ].  This will open the tag location in a new window.

   Help keyword(s): :tag, Ctrl-], v_CTRL_], <C-LeftMouse>,
                    g<LeftMouse>, :stag, Ctrl-W_]

8. How do I come back from a tag jump?

   There are several ways to come back to the old location from a tag
   jump.
        1. You can use the 'pop' ex command.
        2. You can press Ctrl-t.
        3. You can click the right mouse button, while pressing the
           <Ctrl> key.
        4. You can press the g key and then click the right mouse
           button.

   Help keyword(s): :pop, Ctrl-T, <C-RightMouse>, g<RightMouse>

9. How do I jump again to a previously jumped tag location?

   You can use the 'tag' ex command to jump to a previously jumped tag
   location, which is stored in the tag stack.

   Help keyword(s): tag

10. How do I list the contents of the tag stack?

   Vim remembers the location from which you jumped to a tag in the
   tag stack.  You can list the current tag stack using the 'tags' ex
   command.

   Help keyword(s): :tags, tagstack

11. How do I jump to a particular tag match, if there are multiple
    matching tags?

    In some situations, there can be more than one match for a tag.
    For example, a C function or definition may be present in more
    than one file in a source tree.  There are several ways to jump to
    a specific tag from a list of matching tags.
    
        1. You can use the 'tselect' ex command to list all the tag
           matches.  For example,

                :tselect func1

          will list all the locations where func1 is defined.  You can
          then enter the number of a tag match to jump to that
          location.
        2. You can position the cursor over the tag name and press g]
           to get a list of matching tags.
        3. You can visually select a text and press g] to get a list
           of matching tags.
        4. You can use the 'stselect' ex command.  This will open the
           selected tag from the tag list in a new window.
        5. You can position the cursor over the tag name and press
           Ctrl-W g] to do a :stselect.

    Help keyword(s): tag-matchlist, :tselect, g], v_g], :stselect,
                     Ctrl-W_g]

12. I want to jump to a tag, if there is only one matching tag,
    otherwise a list of matching tags should be displayed.  How do I
    do this? 

    There are several ways to make Vim to jump to a tag directly, if
    there is only one tag match, otherwise present a list of tag
    matches.

        1. You can use the 'tjump' ex command.  For example,

                :tjump func1

           will jump to the definition func1, if it is defined only
           once.  If func1 is defined multiple times, a list of
           matching tags will be presented.
        2. You can position the cursor over the tag and press g
           Ctrl-].
        3. You can visually select a text and press g Ctrl-] to jump
           or list the matching tags.
        4. You can use the 'stjump' ex command.  This will open the
           matching or selected tag from the tag list in a new window.
        5. You can press Ctrl-W g Ctrl-] to do a :stjump.

    Help keyword(s): :tjump, g_Ctrl-], v_g_CTRL-], :stjump,
                     Ctrl-W_g_Ctrl-]

13. How do browse through a list of multiple tag matches?

    If there are multiple tag matches, you can browse through all of
    them using several of the Vim ex commands.

    1. To go to the first tag in the list, use the 'tfirst' or
       'trewind' ex command.
    2. To go to the last tag in the list, use the 'tlast' ex command.
    3. To go to the next matching tag in the list, use the 'tnext' ex
       command.
    4. To go to the previous matching tag in the list, use the
       'tprevious' or 'tNext' ex command.

    Help keyword(s): :tfirst, :trewind, :tlast, :tnext, :tprevious,
                     :tNext

14. How do I preview a tag?

    You can use the preview window to preview a tag, without leaving
    the original window.  There are several ways to preview a tag:

        1. You can use the 'ptag' ex command to open a tag in the
           preview window.
        2. You can position the cursor on a tag name and press Ctrl-W
           } to open the tag in the preview window.
        3. You can use the 'ptselect' ex command to do the equivalent
           of the 'tselect' ex command in the preview window.
        4. You can use the 'ptjump' ex command to do the equivalent of
           the 'tjump' ex command in the preview window.
        5. You can position the cursor on the tag and press Ctrl-W g}
           to do a :ptjump on the tag.

    Help keyword(s): :preview-window, :ptag, Ctrl-W_}, :ptselect,
                     :ptjump, Ctrl-W_g}

15. How do I browse through the tag list in a preview window?

    If there are multiple tag matches, you can browse through all of
    them in the preview window using several of the Vim ex commands.

    1. To go to the first tag in the list, use the 'ptfirst' or
       'ptrewind' ex command.
    2. To go to the last tag in the list, use the 'ptlast' ex command.
    3. To go to the next matching tag in the list, use the 'ptnext' ex
       command.
    4. To go to the previous matching tag in the list, use the
       'ptprevious' or 'ptNext' ex command.

    Help keyword(s): :ptfirst, :ptrewind, :ptlast, :ptnext,
                     :ptprevious, :ptNext

16. How do I start Vim to start editing a file at a given tag match?

    While starting Vim, you can use the command line option '-t' to
    supply a tag name.  Vim will directly jump to the supplied tag
    location.

    Help keyword(s): -t

17. How do I list all the tags matching a search pattern?

    There are several ways to go through a list of all tags matching a
    pattern.

        1. You can list all the tags matching a particular regular
           expression pattern by prepending the tag name with the '/'
           search character.  For example,

                :tag /<pattern>
                :stag /<pattern>
                :ptag /<pattern>
                :tselect /<pattern>
                :tjump /<pattern>
                :ptselect /<pattern>
                :ptjump /<pattern>

         2. If you have the 'wildmenu' option set, then you can press
            the <Tab> key to display a list of all the matching tags
            in the status bar.  You can use the arrow keys to move
            between the tags and then use the <Enter> key to select a
            tag.

         3. If you don't have the 'wildmenu' option set, you can still
            use the <Tab> key to browse through the list of matching
            tags.

    Help keyword(s): tag-regexp, wildmenu

18. What options are available to control how Vim handles the tags
    file?

    You can use the following options to control the handling of tags
    file by Vim:

    1. 'tagrelative' - Controls how the file names in the tags file
                       are treated.  When on, the filenames are
                       relative to the directory where the tags file
                       is present.

    2. 'taglength' -  Controls the number of significant characters
                      used for recognizing a tag.

    3. 'tagbsearch' - Controls the method used to search the tags file
                      for a tag.  If this option is on, binary search
                      is used to search the tags file.  Otherwise,
                      linear search is used.

    4. 'tagstack' - Controls how the tag stack is used.

    Help keyword(s): 'tagrelative', 'taglength', 'tagbsearch',
                     'tagstack'

19. Is it possible to highlight all the tags in the current file?

    Yes.  Read the Vim online help on "tag-highlight".

20. Is it possible to create a menu with all the tags in the current
    file?

    Yes.  It is possible to create a menu with all the tags in the
    current file using a Vim script.  Download the TagsMenu.vim script
    from the following link: 

    http://members.home.net/jayglanville/tagsmenu/TagsMenu.html

21. Is there a workaround to make the Ctrl-] key not to be treated as
    the telnet escape character?

    The default escape characters for telnet in Unix systems is
    Ctrl-].  While using Vim in a telnet session, if you use Ctrl-] to
    jump to a tag, you will get the telnet prompt.  There are two ways
    to avoid this problem:
    
    1. Map the telnet escape character to some other character using
       the "-e <escape character>" telnet command line option

    2. Disable the telnet escape character using the "-E" telnet
       command line option.

    Help keyword(s): telnet-CTRL-]
%
This is a *request* for a tip.  I need to be able to pipe the output of a :blah
ex command into the vim text buffer for editing.  I wanted to do this many
times for different reasons and could never find a way!

I would just love to be able to do :hi --> textBuffer and examine the output at
my own leasure scrolling up and down and using vim search commands on it.  Same
thing for :set all, and other things.  Considering that cut and paste is
horrible in windows, I can't for example do :set guioptions? then cut and
paste!  So I have to retype it, or cut and paste from the help manual.  I
really want to be able to pipe the output of ex commands into the text buffer.
Can someone help me?
%
You can - like me :o)  - use gvim, like replacement of internal AutoCad MTEXT
editor. You need switch variable MTEXTED to "gvim" (or maybe fullpath,
something like "c:\vim\vim60aq\gvim" ), and to your _vimrc you can put line:

autocmd BufRead,BufNewFile *.tmp source c:\vim\aacad.vim

And when you edit MTEXT in acad, menu AutoCad will be for your use in gvim
(only in INSERT and VISUAL mode)

[NOTE: Only I can't start gvim like gvim -y (for any other person, not so
accustomed vith gvim) or start gvim from gvim.lnk or gvim.bat (I'am using
windows95) and automatic skip to INSERT mode -latest word star, on end of
script- is without functionality(?) Maybe someone advise me?? ] 

Well, script aacad.vim is listed here:

"VIM menu for AutoCad's MTEXT editation
"brz; mailto:brz@centrum.cz;  8. 8. 2001
" Version Mk.I
"--------------------------------------------------------------------------

imenu &AutoCad.Insert.Space \~
vmenu &AutoCad.Insert.Space <Esc>`<i\~<Esc>%
imenu &AutoCad.Insert.Backslash \\
vmenu &AutoCad.Insert.Backslash <Esc>`<i\\<Esc>%
imenu &AutoCad.Insert.Brackets \{\}<Esc>F\i
vmenu &AutoCad.Insert.Brackets <Esc>`>a\}<Esc>`<i\{<Esc>%
imenu &AutoCad.Insert.Paragraph \P
vmenu &AutoCad.Insert.Paragraph <Esc>`>a\P<Esc>%

imenu &AutoCad.-SEP1- :

imenu &AutoCad.Colour.Red \C1;
vmenu &AutoCad.Colour.Red <Esc>`>a\C7;<Esc>`<i\C1;<Esc>%
imenu &AutoCad.Colour.Yellow \C2;
vmenu &AutoCad.Colour.Yellow <Esc>`>a\C7;<Esc>`<i\C2;<Esc>%
imenu &AutoCad.Colour.Green \C3;
vmenu &AutoCad.Colour.Green <Esc>`>a\C7;<Esc>`<i\C3;<Esc>%
imenu &AutoCad.Colour.Cyan \C4;
vmenu &AutoCad.Colour.Cyan <Esc>`>a\C7;<Esc>`<i\C4;<Esc>%
imenu &AutoCad.Colour.Blue \C5;
vmenu &AutoCad.Colour.Blue <Esc>`>a\C7;<Esc>`<i\C5;<Esc>%
imenu &AutoCad.Colour.Violet \C6;
vmenu &AutoCad.Colour.Violet <Esc>`>a\C7;<Esc>`<i\C6;<Esc>%
imenu &AutoCad.Colour.Black \C7;
vmenu &AutoCad.Colour.Black <Esc>`>a\C7;<Esc>`<i\C7;<Esc>%
imenu &AutoCad.Colour.D_Grey \C8;
vmenu &AutoCad.Colour.D_Grey <Esc>`>a\C7;<Esc>`<i\C8;<Esc>%
imenu &AutoCad.Colour.L_Grey \C9;
vmenu &AutoCad.Colour.L_Grey <Esc>`>a\C7;<Esc>`<i\C9;<Esc>%

imenu &AutoCad.Font.Arial \fArial;
vmenu &AutoCad.Font.Arial <Esc>`<i\fArial;<Esc>%
imenu &AutoCad.Font.Symbol \Fsymbol;
vmenu &AutoCad.Font.Symbol <Esc>`<i\Fsymbol;<Esc>%
imenu &AutoCad.Font.RomanC \Fromanc;
imenu &AutoCad.Font.RomanC <Esc>`<i\Fromanc;<Esc>%
imenu &AutoCad.Font.RomanS \Fromans;
vmenu &AutoCad.Font.RomanS <Esc>`<i\Fromans;<Esc>%
imenu &AutoCad.Font.RomanD \Fromand;
vmenu &AutoCad.Font.RomanD <Esc>`<i\Fromand;<Esc>%
imenu &AutoCad.Font.RomanT \Fromant;
vmenu &AutoCad.Font.RomanT <Esc>`<i\Fromant;<Esc>%

imenu &AutoCad.Size.0_5x \H0.5x;
vmenu &AutoCad.Size.0_5x <Esc>`<i\H0.5x;<Esc>%
imenu &AutoCad.Size.1_5x \H1.5x;
vmenu &AutoCad.Size.1_5x <Esc>`<i\H1.5x;<Esc>%
imenu &AutoCad.Size.2x \H2x;
vmenu &AutoCad.Size.2x <Esc>`<i\H2x;<Esc>%
imenu &AutoCad.Size.3x \H3x;
vmenu &AutoCad.Size.3x <Esc>`<i\H3x;<Esc>%

imenu &AutoCad.Effects.Set_Out_1_5 \T1.5;
vmenu &AutoCad.Effects.Set_Out_1_5 <Esc>`>a\T1;<Esc>`<i\T1.5;<Esc>%
imenu &AutoCad.Effects.Set_Out_2 \T2;
vmenu &AutoCad.Effects.Set_Out_2 <Esc>`>a\T1;<Esc>`<i\T2;<Esc>%

imenu &AutoCad.Effects.-SEP3- :
imenu &AutoCad.Effects.Tilt_15deg \Q15;
vmenu &AutoCad.Effects.Tilt_15deg <Esc>`>a\Q0;<Esc>`<i\Q10;<Esc>%
imenu &AutoCad.Effects.Tilt_20deg \Q20;
vmenu &AutoCad.Effects.Tilt_20deg <Esc>`>a\Q0;<Esc>`<i\Q20;<Esc>%
imenu &AutoCad.Effects.Tilt_30deg \Q30;
vmenu &AutoCad.Effects.Tilt_30deg <Esc>`>a\Q0;<Esc>`<i\Q30;<Esc>%

imenu &AutoCad.Effects.-SEP4- :
imenu &AutoCad.Effects.Change_Width_0_5x \W0.5;
vmenu &AutoCad.Effects.Change_Width_0_5x <Esc>`>a\W1;<Esc>`<i\W0.5;<Esc>%
imenu &AutoCad.Effects.Change_Width_2x \W2;
vmenu &AutoCad.Effects.Change_Width_2x <Esc>`>a\W1;<Esc>`<i\W2;<Esc>%

imenu &AutoCad.Effects.-SEP5- :
imenu &AutoCad.Effects.Justify_Down \A0;
vmenu &AutoCad.Effects.Justify_Down <Esc>`<i\A0;<Esc>%
imenu &AutoCad.Effects.Justify_Middle \A1;
vmenu &AutoCad.Effects.Justify_Middle <Esc>`<i\A1;<Esc>%
imenu &AutoCad.Effects.Justify_Up \A2;
vmenu &AutoCad.Effects.Justify_Up <Esc>`<i\A2;<Esc>%
imenu &AutoCad.Effects.Overlined_Characters \O\o<Esc>F\i
vmenu &AutoCad.Effects.Overlined_Characters <Esc>`>a\O<Esc>`<i\o<Esc>%
imenu &AutoCad.Effects.Underlined_Characters \L\l<Esc>F\i
vmenu &AutoCad.Effects.Underlined_Characters <Esc>`>a\l<Esc>`<i\L<Esc>%
imenu &AutoCad.Effects.Index_Top \S^;

imenu &AutoCad.-SEP6- :
imenu &AutoCad.Help <CR><CR>***Quit Editor: press Alt-F4 and 'No' ***<CR><CR>

star
%
This is a *request* for a tip.
Sometimes (eg. editing HTML pages) I need to add a timestamp string to my
editing buffer.
On UNIX systems, I can use  
  :r!date  
to get a localized date time string; but on Windows ('date' on Windows will
query the user to input new date)
or other platforms which does not have 'date' command, how do I get a timestamp
easily?
%
There have been a few "requests for tips" entered into the tips database
lately.  If you have specific questions that aren't answered by the existing
tips, there are a couple of resources that may be more appropriate:

The mailing list vim@vim.org is for vim users.  If you send an email to
vim-help@vim.org, you'll get a message back telling you how to subscribe, as
well as how to request old messages and contact the list maintainer.  This
mailing list is also archived at http://groups.yahoo.com/group/vim.

The newsgroup comp.editors discusses many different editors, but most of the
traffic is about vim.  When posting, it is appreciated if you include "vim" in
the subject line.  The comp.editors newsgroup is archived at
http://groups.google.com/groups?hl=en&safe=off&group=comp.editors.

Using the tips database for asking questions is not likely to work well.  For
example, if you ask a question titled "Searching for strings in a file" and I
read this site and see that tip, I'm not going to read it if I already know how
to search for strings in a file.  In comp.editors and vim@vim.org, people
expect to find questions from others and are therefore more likely to see your
questions.

After finding the answer to your question, please consider whether it would
make an appropriate tip, and if so, add it to the tips database.
%
Here's a (what should be a one-line) map to help you tell just what
syntax highlighting groups the item under the cursor actually is:

map  <F10>  :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '>
trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" .
synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

Once known you can override the current highlighting with whatever you want.
If you're debugging a syntax highlighting file (a rare occupation), sometimes
you'll wish to know the entire chain of syntax highlighting.  For that,
check out

http://www.erols.com/astronaut/vim/vimscript/hilinks.vim
%
You're a newbie in vim and need some ":help"? Well, help.txt reads:

"Jump to a subject:  Position the cursor on a tag between |bars| and hit CTRL-]."

Unfortunately there is no "]" key on German keyboards. On Win32 try CTRL-+
(Strg-+), on Linux console I use CTRL-AltGr-9 (Strg-AltGr-9).

Kind regards
%
To change automatically to the directory the file in the current buffer is in
add a line (below)  to the file .vimrc .
The file .vimrc should have the following if-statement to control the autocmd
feature:


  if has("autocmd")
	
    < ... lot of autocmd stuff ... >
	
    " Change to the directory the file in your current buffer is in
    autocmd BufEnter * :cd %:p:h
	
  endif " has("autocmd")


Add the line above the endif and restart vim/gvim.
%
I'm used to complete words with <tab>, however when editing source I can't just
map that to vim keyword completion because I sometime need to insert real tabs,
since it mostly happen when at the beginning of the line or after a ; and
before a one line comma (java, c++ or perl anyone...) I've come to find the
following really usefull
This is how you can map the <tab> key in insert mode while still being able to
use it when at the start of a line or when the preceding char is not a keyword
character.
in a script file in a plugin directory or in your .vimrc file:
first define a function which returns a <tab> or a <C-N> depending on the context:

function InsertTabWrapper()
      let col = col('.') - 1
      if !col || getline('.')[col - 1] !~ '\k'
          return "\<tab>"
      else
          return "\<c-p>"
      endif
endfunction

then define the appropriate mapping:
inoremap <tab> <c-r>=InsertTabWrapper()<cr>

the trick here is the use of the <c-r>= in insert mode to be able to call your
function without leaving insert mode.
:help i_CTRL-R
Benoit
%
When working with Python and other languages which don't use braces, it's
useful to be able to jump to and from lines which have the same indentation as
the line you are currently on.

nn <M-,> k:call search ("^". matchstr (getline (line (".")+ 1), '\(\s*\)')
."\\S", 'b')<CR>^
nn <M-.> :call search ("^". matchstr (getline (line (".")), '\(\s*\)') ."\\S")<CR>^

will map Alt-< and Alt-> in Normal mode to upward and downward searching for
lines with the same indent as the current line.
%
DBI::Shell is a Perl module that is used as a shell interface to Perl's popular
DBI (database interface) package. Forget your favorite SQL navigation gui and
give this method a shot. This has only been tested in UNIX.

1. run dbish (runs DBI::Shell; installed with DBI::Shell) and connect to any database
2. in dbish, set /format box
3. enter your query
4. to execute query, type "/ | vim -"

This runs the query and pipes the output to the standard input of vim. Here are
some follow-up tips:
-use gvim instead of vim so a new window will pop up
-set nowrap once in vim
-make a syntax highlighting file for me!

-Adam Monsen
%
I sometimes found myself moving down a few lines with j, then scrolling down
about the same number of lines with <C-E> to put the cursor in roughly the
same place as it started.  I decided I wanted to map <C-J> (and <C-K>,
respectively) to the move-and-scroll operation.  First, I did

    :map <C-J> <C-E>j

This was pretty good, but behaved funny at the beginning and end of files.
Then, I realized that <C-D> already combined move and scroll, so I figured
that giving <C-D> a count of 1 would do it:

    :map <C-J> 1<C-D>

Unfortunately, this permanently attaches a count to <C-D> (ugh!), so I have
to undo that:

    :map <C-J> 1<C-D>:set scroll=0<CR>

This has the drawback of not necessarily resetting scroll to its original
value, but since I never change scroll, it's good enough for me.  It would
be nice if there were a version of <C-D> that did not have the side-affect
of changing scroll.

Happy vimming,
Andrew
%
Hallo,
next solution for _most_simple_ signature rotater: 
You can only put one line to your .vimrc || _vimrc:
map <Leader>ms :e
c:\sign.txt<CR>ggV/--<CR>k"*xG$a<C-R><C-O>*<Esc>:w<CR>:bd<CR>G$a<C-M><Esc>"*P

Must exist file (from eg above) c:\sign.txt, with content:
--
first signature
--
second signature
--
third signature
--

When You finished mail, only call shortcut \ms and 'first signature' will be
insert in your mail. In c:\sign.txt will be first signature pushed to the end
of this file. When You want use other signature, only press 'u' and \ms again
(Or You can change \ms to e.g. <F12>, indeed. ) You can change this and append
one part like 'basic' from command and append 'changing' part from .signature
file, as you like...
Ok, one unpleasant thing is here: your signature must not contain '--'
(signature separator)...
Anyhow, I find it useful
brz* <brz@centrum.cz>
http://brz.d2.cz/
%
When testing your own C/C++ programs you sometimes wish to have a trace output,
which shows you, which enum value is used.
You can do this by creating a string table for that enum type,
which contains the enum identifyer as a string.
e.g.
printf ("%s", MyEnumStringTable [ MyEnumVal] );

You can create the complete string table by 
- marking the lines containing the complete typedef enum
- select menu C/C++.transform enum2Stringtab

You can create string table entries by 
- marking the lines within the typedef enum
- select menu C/C++.transform enum2String

This makes it easy to keep the enum (on changes) consistent to the string table.

Add the following lines to your _GVIMRC file:
31amenu C/C++.transform\ enum2Stringtab 	:s#[ 	]*\\(\\w\\+\\)#/* \\1	*/
"\\1"#<CR>o};<ESC>uOstatic const char* const Names[] = {<ESC><CR>/sdfsdf<CR>
31vmenu C/C++.transform\ enum2Stringtab 	:s#[ 	]*\\(\\w\\+\\)#/* \\1	*/
"\\1"#<CR>o};<ESC>uOstatic const char* const Names[] = {<ESC><CR>/sdfsdf<CR>

31amenu C/C++.transform\ enum2String 	:s#[ 	]*\\(\\w\\+\\)#/* \\1	*/
"\\1"#<CR>o}<ESC>/sdfsdf<CR>
31vmenu C/C++.transform\ enum2String 	:s#[ 	]*\\(\\w\\+\\)#/* \\1	*/
"\\1"#<CR>o}<ESC>/sdfsdf<CR>

hint: '/sdfsdf' is added for deactivating search highlighting,
ok, you'll sure find a better way to do this.
%
When viewing/editing a folded file, it is often needed to inspect/close some fold.
To speed up these operation use the following (put in your $HOME/.vimrc):

" Toggle fold state between closed and opened. 
"
" If there is no fold at current line, just moves forward.
" If it is present, reverse it's state.
fun! ToggleFold()
	if foldlevel('.') == 0
		normal! l
	else
		if foldclosed('.') < 0
			. foldclose
		else
			. foldopen
		endif
	endif
	" Clear status line
	echo
endfun

" Map this function to Space key.
noremap <space> :call ToggleFold()<CR>


See :help folding for more information about folding.
%
Often I know I'm likely to edit many files. I run 'vim *.pl' and get a whole
bunch of open files.

To make jumping between files to a pleasure, I defined to mapss:

map <f1> :previous<cr>
map <f2> :next<cr>

Press F1 to go back and F2 to go forward.

-- 
Kirill
%
Below are two functions and a mapping which will convert lines of plain text into
HTML table code.
For example, you have several lines like:
-----------------------------------------------
1
2
3

4
5
6
---------------------------------------------------
by visualizing all the 7 lines and press <F5>, you can change the text into
<table><tr>
   <td>1</td>
   <td>2</td>
   <td>3</td>
</tr><tr>
   <td>4</td>
   <td>5</td>
   <td>6</td>
</tr></table>
which will eventually render into a table. 
So the rule is:
Every line is a table item, every empty line means starting of a new table row.



"A text->html table code converter
"By: Wenzhi Liang wzhliang@yahoo.com
"You can distribute/change this file freely as long as you keep the title area.
Thanks

func Table()
	let end=line("'>")
	let start=line("'<")
	let i=start

	wh i <= end
		exe ":" . i
		let e=Empty()
		if e == 1
			exe "normal I</tr><tr>"
		else
			exe "normal I<td>A</td>>>"
		endif
		let i=i+1
	endwh

	exe "normal o</tr></table><<"
	exe ":" . start
	exe "normal O<table><tr><<"
endfunc

vmap <F5> <ESC>:call Table()<CR>

func Empty()
	let line_nr= line (".")
	let a=getline ( line_nr )
	let m=match(a, "\\S")
	if m == -1 
		return 1
	else
		return 0
	endif
endfunc
%
I have found it undesirable to use :hardcopy directly because it uses the
current syntax highlighting to determine how to print the text.  For example, I
like to print comments in italics, but I don't like italic fonts on the screen.
This tip will show you how to set up a colorscheme for printing and use it only
when you print.

I copied an existing colorscheme to ~/.vim/colors/print.vim, and changed all
the lines like this:

  highlight Normal ctermbg=DarkGrey ctermfg=White guifg=White guibg=grey20
to this:
  highlight clear Normal

Then I set the syntax groups how I wanted them to be printed on the printer:

  highlight Comment        term=italic    cterm=italic    gui=italic
  highlight Constant       term=bold      cterm=bold      gui=bold
  etc....

I then defined the following command in my .vimrc file:

command! -nargs=* Hardcopy call DoMyPrint("<args>")

And, finally, I defined this function in my .vimrc:

function DoMyPrint(args)
    let colorsave=g:colors_name
    color print
    exec "hardcopy ".a:args
    exec 'color '.colorsave
endfunction


After this is complete, you can do:
   :Hardcopy > /tmp/out.ps
or just
   :Hardcopy
(Note the capital H)
%
Paul Wright posted a tip which explained how to jump back and forth between
lines with the same indentation level. I do this a lot, so I came up with this
slightly more comprehensive solution.

The example mappings below work as follows:

[l and ]l jump to the previous or the next line with the same indentation level
as the one you're currently on.

[L and ]L jump to the previous or the next line with an indentation level lower
than the line you're currently on.

These movements also work in visual mode and (only as of one of the 6.0 alpha
versions) in operator pending mode, meaning that you can do a d]l. The motion
is specified as being exclusive when in operator pending mode.

When might you use this? If you're writing programs in Python, Haskell, or
editing XML files, they will be very useful. E.g. in XML you can jump to the
outer enclosing tag, or the next matching tag. I use it for practically
anything I edit, so it's not limited to this.



"
" NextIndent()
"
" Jump to the next or previous line that has the same level or a lower
" level of indentation than the current line.
"
" exclusive (bool):   true:  Motion is exclusive
"                     false: Motion is inclusive
" fwd (bool):         true:  Go to next line
"                     false: Go to previous line
" lowerlevel (bool):  true:  Go to line with lower indentation level
"                     false: Go to line with the same indentation level
" skipblanks (bool):  true:  Skip blank lines
"                     false: Don't skip blank lines

function! NextIndent(exclusive, fwd, lowerlevel, skipblanks)
	let line = line('.')
	let column = col('.')
	let lastline = line('$')
	let indent = indent(line)
	let stepvalue = a:fwd ? 1 : -1

	while (line > 0 && line <= lastline)
		let line = line + stepvalue
		if (	! a:lowerlevel && indent(line) == indent ||
				\ a:lowerlevel && indent(line) < indent)
			if (! a:skipblanks || strlen(getline(line)) > 0)
				if (a:exclusive)
					let line = line - stepvalue
				endif
				exe line
				exe "normal " column . "|"
				return
			endif
		endif
	endwhile
endfunc


" Moving back and forth between lines of same or lower indentation.
nnoremap <silent> [l :call NextIndent(0, 0, 0, 1)<cr>
nnoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<cr>
nnoremap <silent> [L :call NextIndent(0, 0, 1, 1)<cr>
nnoremap <silent> ]L :call NextIndent(0, 1, 1, 1)<cr>
vnoremap <silent> [l <esc>:call NextIndent(0, 0, 0, 1)<cr>m'gv''
vnoremap <silent> ]l <esc>:call NextIndent(0, 1, 0, 1)<cr>m'gv''
vnoremap <silent> [L <esc>:call NextIndent(0, 0, 1, 1)<cr>m'gv''
vnoremap <silent> ]L <esc>:call NextIndent(0, 1, 1, 1)<cr>m'gv''
onoremap <silent> [l :call NextIndent(0, 0, 0, 1)<cr>
onoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<cr>
onoremap <silent> [L :call NextIndent(1, 0, 1, 1)<cr>
onoremap <silent> ]L :call NextIndent(1, 1, 1, 1)<cr>
%
Hallo, today I found script "translate.vim", but on Windows this will be
probably difficult to run it (maybe with Cygwin is it possible). I've simpler
solution of keymap for vim interlacing to dictionary: 
Must exist file with vocabulary (e.g. "an-cs.txt"), which is called for word
under cursor. In 'normal' is only displayed window with translations, in
'insert' is word under cursor deleted and is insert selected form of word from
translantion window (select it by mouse and than press right button: It works
fine on W2k). Key _F12_ is looking for "word", shifted _S-F12_ is looking for
"pattern". 
For windows is needed agrep, which is localy placed on
http://www.tgries.de/agrep/index.html

map <F12> b"*yw<Esc>:! c:/bin/agrep -wih <C-R>* "c:/dict/an-cs.txt"<CR>
imap <F12> <Esc>b"*yw<Esc>:! c:/bin/agrep -wih <C-R>*
"c:/dict/an-cs.txt"<CR>dwi <C-R>* 
map <S-F12> b"*yw<Esc>:! c:/bin/agrep -ih <C-R>* "c:/dict/an-cs.txt"<CR>
imap <S-F12> <Esc>b"*yw<Esc>:! c:/bin/agrep -ih <C-R>*
"c:/dict/an-cs.txt"<CR>dwi <C-R>*
	
brz* <brz@centrum.cz>
%
It can be done by reaching the blank lines in up and down directions just by pressing

{    ----  For going to the blank line above the paragraph
}    ----  For going to the blank line below the paragraph
%
It can be done by reaching the blank lines in up and down directions just by pressing

{    ----  For going to the blank line above the paragraph
}    ----  For going to the blank line below the paragraph
%
Sometimes it is useful to know all the occurances of the word under cursor in
all the open files. This can be done by pressing [I ( bracket and capital I ) .
it shows the results found in the command window.
%
Searching for a word across the project wastes most of the developres time,
which can be avoided by the use of GNU Id_utils with VIM. 
The procedure needs to be followed is as follows:
download GNU idutils 3.2d (mkid,lid,fid,fnid,xtokid) 
from http://www.mossbayeng.com/~ron/vim/builds.html

uncompress and store these files in the directory from where vim is running.

goto the top level directory of the project, and run mkid, it will create ID
file in that directory (As it is time consuming process, so be patient). copy
this file ID to the directory from where vim is running.

USAGE:

Put these lines in your .vimrc:

	map _u :call ID_search()<Bar>execute "/\\<" . g:word . "\\>"<CR>
	map _n :n<Bar>execute "/\\<" . g:word . "\\>"<CR>

	function ID_search()
	  let g:word = expand("<cword>")
	  let x = system("lid --key=none ". g:word)
	  let x = substitute(x, "\n", " ", "g")
	  execute "next " . x
	endfun

To use it, place the cursor on a word, type "_u" and vim will load the file
that contains the word.  Search for the next ocurance of the word in the same
file with "n".  Go to the next file with "_n".

The mapping of "_u" and "_n" can be done to some other key as per your
preference but I use ^K and ^L for this purpose.
%
Within the registry, you can specify the source editor to be used by Internet
Explorer when {View|Source} is selected. Unfortunately, you can't specify a
quoted filename argument here, i.e. "%1". The editor specified is supposed to
handle filenames which contain spaces. This will cause problems for Vim because
Vim treats each space as an argument separator. If an unquoted filename
contains spaces, Vim treats the filename as multiple arguments and will open
multiple files instead of one. To workaround this problem a quoted filename has
to be passed to Vim. This can be done by creating the following Visual Basic
Script file gVim.vbs:

'--- gVim.vbs -----------------------------------------------------------------
'function: Start gvim, combining multiple arguments to single file argument.
'changes:  20010905: Quoted 'oWShell.Run' filename argument, allowing spaces.
'          20010518: Created.
'author:   Freddy Vulto <fvu@fvu.myweb.nl>

  ' Making variable declaration mandatory
option explicit

dim oWShell, sArg, sFile

  ' Create script object
set oWShell = CreateObject("wscript.shell")
  ' Loop through arguments
for each sArg in wscript.arguments
    ' Add argument to filename
  sFile = sFile & sArg & " "
next
  ' Remove excess space
sFile = Trim(sFile)
  ' Run Vim with file argument.  Additional arguments:
  ' -R: View file readonly
  ' -c "set syntax=html": Use HTML syntax-highlighting
  '    NOTE: Use "-c ""set ft=html""" to make it work for Vim v6.
oWShell.Run _
  """D:\Programs\Vim\Vim58\gvim.exe """ & _
  "-R """ & sFile & """ " & _
  "-c ""set syntax=html"""

  ' Destroy script object
set oWShell = NOTHING


The source editor now can be specified by adding the following key to the registry:


HKEY_LOCAL_MACHINE
|- Software
   |- Microsoft
      |- Internet Explorer
         |- View Source Editor
            |- Editor Name       (Default) = D:\Programs\Vim\gvim.vbs


Freddy Vulto <fvu@fvu.myweb.nl>
http://fvu.myweb.nl/Projects/Vim/Web/vim.htm
%
I really like the new explorer window, but I wanted it to function a little
more seemlessly in the editor.  The following code does two things.  First, the
explorer is started when vim is started.   I also noticed and fixed that the
explorers size is not equal to the window size, hence the strange behavior when
popping between two windows.  The other major function of the code is to close
the explorer when it's the only window that's left.  I'd actually like to take
this a step further and close the window if the last _document_ window is
closed.  I'd prefer that multiple explorers or help windows don't keep the
application running - only having a file open keeps the application running.
But I didn't see an easy way to do this... anyone else?

BTW, thank you Bram for the help figuring this out.

Code (which currently lives in my _vimrc):

" FILE BROWSER STARTUP
func OpenFileWindow()
	" :runtime plugin/*.vim		" this would be useful if you were calling this
				"   function from the .vimrc directly
	let g:explDetailedList=1	" show size and date by default
	let g:explVertical=1		" Split vertically
	let g:explStartRight=0    	" Put new explorer window to the left of the
	current window
	:Sexplore
	set nonu
	set winwidth=15		" Make the width of the window match the explorer setting
	"let g:explVertical=0		" Split vertically
	doautocmd fileExplorer BufEnter " Forces the directory refresh to occur
	:winc l			" change to the document window
endfunc
	
func CloseIfLast()
	if exists("b:completePath")	" this is how I determine that I'm in an explorer window
		let n = winnr()
		wincmd p
		if n == winnr()
			quit	" quit the window
		endif
		wincmd p
	endif
endfunc

if has("autocmd")
	if !exists("rudyautocommands")
		let rudyautocommands = 1
		autocmd VimEnter * call OpenFileWindow()
		autocmd WinEnter * call CloseIfLast()

	endif
endif
%
VimTip 120: Compiling Java with Sun JDK (javac) within VIM
http://vim.sf.net/tips/tip.php?tip_id=120

The $VIMRUNTIME/compiler has 'jikes.vim', but there's nothing for traditional
Sun JDK(javac),
so I tried (Only tested on Win 2000):

" Vim Compiler File    javac.vim
" Compiler:	Sun/IBM JDK: Javac

if exists("current_compiler")
  finish
endif
let current_compiler = "javac"

" Javac defaults to printing output on stderr and no options can convert, so we
have to set 'shellpipe'
setlocal shellpipe=2> 
" 2> works on Win NT and UNIX
setlocal makeprg=javac\ #<.java
setlocal errorformat=%f:%l:%m
" Sorry I'm not familiar with 'errorformat', so I set it very simple.
%
If you want to use Vim's syntax highlighting in a "more"-style pager, here's
one way to set it up:

First, create a vimrc like the following -- I called mine ~/.vimrc.more

---8<---cut here---8<---
" No compatibility -- necessary for mappings to work.
set nocompatible

" Status line
set laststatus=0
set cmdheight=1
set nomodifiable	" Only in version 6.0
set readonly

" Syntax colouring -- lines taken from syntax.txt discussion on colour xterms.
" See ':help color-xterm'. Use appropriate lines for your own set-up.
if has("terminfo")
    set t_Co=16
    set t_Sf=[3%p1%dm
    set t_Sb=[4%p1%dm
else
    set t_Co=16
    set t_Sf=[3%dm
    set t_Sb=[4%dm
endif
" My xterms have a navy-blue background, so I need this line too.
set background=dark
" Turn syntax on
syntax on

" Key bindings.
nmap b <C-B><C-G>
nmap q :q<CR>
" To type the following line, type *two* C-V's followed by two spaces. This
" is how you map the spacebar.
nmap ^V  <C-F><C-G>
---8<---cut here---8<---

Then, to use this .vimrc, add an alias. If you're using tcsh, the syntax will
be something like:

alias vmore "vim -u ~/.vimrc.more"

Then you can type "vmore [filename]" to view a file in this "pager". Spacebar
will move down, 'b' will move back up, and 'q' quits. You can add mappings for
other keys if you want to, also.
%
I love the text folding capabilities of vim.  I didn't like that it would
display the first line of the range as the "title" for the fold.  I like to
write my comments with the "/*" on a line by itself.  So I wrote this little
function that will skip over anything that isn't a character, and then display
whatever it finds after that character.

Just include this in your ~/.vimrc (or ~/.gvimrc):

function GetFirstLineWithChars()
	let line_num = 0
	let charline = matchstr(getline(v:foldstart), '[a-zA-Z][a-zA-Z ]*')
	while strlen(charline) == 0
		let line_num = line_num + 1
		let charline = matchstr(getline(v:foldstart + line_num), '[a-zA-Z][a-zA-Z ]*')
	endw
	return charline
endfunction
set
foldtext='+'.v:folddashes.substitute(GetFirstLineWithChars(),'\\\/\\\/\\\|\\*\\\|\\*\\\|{{{\\d\\=','','g')
set fillchars=fold: 
hi folded guibg=black guifg=yellow gui=bold

And as an added bonus, for those new to text folding, add this to your .vimrc
file too:

autocmd BufWinLeave *.* mkview
autocmd BufWinEnter *.* silent loadview

That way whatever folds you set won't get lost when you quit.  I had that
happen after spending 15 minutes folding up a 3000+ line file.  Happy vimming!
%
The use of star as in vimtip#1 and vimtip#5 is great, here is how to use this
type of search accross a 
whole directory:
Just add the mappings (or choose different letter combinations):
map gr :grep <cword> *<cr>   
map gr :grep <cword> %:p:h/*<cr>   
map gR :grep \b<cword>\b *<cr>
map GR :grep \b<cword>\b %:p:h/*<cr>


mapping one will search for the word under the cursor (like g*) in any of the
files in the current directory 
mapping two will search for the word under the cursor (like g*) in any of the
files in the same directory as the current file
mapping three will search for the word under the cursor by itself (i.e.
surrounded by word boundary like *) in any of the files in the current
directory
mapping four will search for the word under the cursor by itself (i.e.
surrounded by word boundary like *) in any of the files in the same directory
as the current file

Benoit
%
Below is a way to number a set of lines.  Here is an exaple before and after
snapshot:

apple
bob
pear
tree

1 apple
2 bob
3 pear
4 tree

" Description:
" This provides a command and a function.  They both can be called with or
" without a range.  In addition, they can be called with or without
" arguments.  Without a range they operate on the current line.
"
" There are two supported arguments.  They are described below:
"     arg1 -> the number to start at.  The default is one.  This will
"             number your selected lines sequentially.  The start can be a
"             number, ., $, or, 'x (like getline).
"     arg2 -> Text to append after numbers.  The default is a space.
"
" Examples:
"     To provide your functionality:
"         :%Nlist 20
"         :%call Nlist(20)
"     To make a list start at 1:
"         :'<,'>Nlist
"         :'<,'>call Nlist()
"     To number the whole buffer (with it's actual line number):
"         :%Nlist
"         :%call Nlist()
"     To number a subset of lines with their line number (and put a '] ' in
"     front of every number):
"         :'<,'>Nlist . ]\
"         :'<,'>call Nlist(".", "] ")

command! -nargs=* -range Nlist <line1>,<line2>call Nlist(<f-args>)
function! Nlist(...) range
    if 2 == a:0
        let start = a:1
        let append = a:2
    elseif 1 == a:0
        let start = a:1 
        let append = " "
    else
        let start = 1
        let append = " "
    endif

    " try to work like getline (i.e. allow the user to pass in . $ or 'x)
    if 0 == (start + 0)
        let start = line(start)
    endif

    exe a:firstline . "," . a:lastline . 's/^/\=line(".")-a:firstline+start.append/'
endfunction
%
I always wanted a script that would auto-comment the end of a conditional
block.  So, I wrote one.  This function searches for the previous matching "{",
grabs the line, and inserts it as a comment after the "}".  If there is no
previous matching "{", it inserts nothing.

So...

    if (test){


will generate:
    } // if (test)

This is obviously not work if you use a different style.  If you use 

   if (test)
   {

then substituting 'getline(".")', use  'getline(line(".") - 1)' should work.

Put the following in your .vimrc:
au BufNewFile,BufRead *.c,*.cc,*.C,*.h imap } <ESC>:call CurlyBracket()<CR>a
 
function CurlyBracket()
  let l:my_linenum = line(".")
  iunmap }
  sil exe "normal i}"
  imap } <ESC>:call CurlyBracket()<CR>
  let l:result1 =  searchpair('{', '', '}', 'bW')
  if (result1 > 0)
    let l:my_string = substitute(getline("."), '^\s*\(.*\){', '\1', "")
    sil exe ":" . l:my_linenum
    sil exe "normal a //" . l:my_string
  endif
endfunction
%
Having problems setting up your syntax highlighting because
everything is coming up in bold?

You're probably using an 8 color xterm and setting up highlighting
lines such as  hi Normal ... ctermfg=green .  The solution: use
numbers! 0=black, 1=red, 2=green, 3=yellow, 4=blue, 5=magenta,
6=cyan, and 7=white.  Vim tries to use "bright" colors when its
given names (because Windoz machines prefer to use dim text unless
its been made bold).

Read more about it under :help highlight-ctermfg .
%
I've found while writing HTML files that it can become cumbersome when I have
to switch to a web browser, load my page, and move back to VIM regularly to
preview what I've written.  I've come up with the following tricks.

The first one requires that you have lynx (the text-based browser) installed on
your computer (available from http://lynx.isc.org/release/).  If your HTML page
is primarily text, with few (if any) images, you can set up the following
function and mapping:

   function PreviewHTML_TextOnly()
      let l:fname = expand("%:p" )
      new
      set buftype=nofile nonumber
      exe "%!lynx " . l:fname . " -dump -nolist -underscore -width " . winwidth( 0 )
   endfunction

   map <Leader>pt  :call PreviewHTML_TextOnly()<CR>

This will open a new window and display your formatted HTML document in that
window.  Note that bold-face, italics, links, etc. will be lost -- all you will
see is the text -- but the "-underscore" parameter to Lynx causes any text that
would have been bold, italicized, or underlined to be displayed like _this_.

The other trick requires that vim be running on your current machine, and that
you be running a GUI of some sort (X-Windows, Windows, etc.).  You can cause
vim to invoke your favorite browser and have it display the file, like this:
   function PreviewHTML_External()
      exe "silent !mozilla -remote \"openurl(file://" . expand( "%:p" ) . ")\""
   endfunction

   map <Leader>pp :call PreviewHTML_External()<CR>
If you don't use mozilla, you will need to modify the function to use your
preferred browser.

Happy vimming!
%
	 If you use Vim on Windows, and you wish you had some of those nifty UNIX
	 command-line tools,
but do not feel like installing all of Cygwin, you can get many of the
most-used tools from Ron Aaron's
web site:
http://www.mossbayeng.com/~ron/vim/builds.html
Since Ron is a big Vim fan (see http://www.mossbayeng.com/~ron/vim/vimrant.html
) you can count on
these tools' working well with Vim.  For some hints on how to use them, read
:help :grep
:help lid
inside Vim.
     Happy Vimming!
%
	 If you include the "r" flag in the 'formatoptions' option (:help 'fo' ,
	 :help fo-table ) then the comment leader is inserted
automatically when you start a new line in a comment.  For example, in TeX the
"%" character is the comment leader,
and you might type

 % This is a tex file.
 % The comment leaders on all lines but the first were generated automatically.
 % This is the last line of the comment, but Vim will insert the comment leader
 % on the next line.
%
You can get rid of the comment leader (along with anything you may already have
typed on the line) without affecting
the indent, if any, by typing "<C-U>" while in Insert mode.

	 Related point:  if you want to adjust the indent while in Insert mode, you
	 can use "<C-D>" (to Decrease the indent)
or "<C-T>" (to increase it).  In the docs for Vim 6.0, this is described in the
users' manual, :help 30.4 .
%
     For an overview of ftplugins (filetype plugins) see

:help ftplugins

If you want to disable all ftplugins, or disable a particular default ftplugin, see

:help :filetype
:help ftplugin-overrule

If you have your own ftplugins, and you want to disable all the default ones, then
do NOT include a check for b:did_ftplugin in your ftplugin files, and add the line

:autocmd BufEnter * let b:did_ftplugin = 1

to your VIMRC file, BEFORE the ":filetype ftplugin on" line.
%
This mapping allow you to quickly scroll inactive window when displaying
several windows concurrently.

nmap <silent> <M-Down> :call ScrollOtherWindow("down")<CR>
nmap <silent> <M-Up> :call ScrollOtherWindow("up")<CR>

fun! ScrollOtherWindow(dir)
	if a:dir == "down"
		let move = "\<C-E>"
	elseif a:dir == "up"
		let move = "\<C-Y>"
	endif
	exec "normal \<C-W>p" . move . "\<C-W>p"
endfun

PS: Original idea and discussion of this tip appeared on vim@vim.org mailing
list, I'm just prettified it a little.
%
i frequently have multiple windows open in vim -- this reduces the number of
lines each window displays -- i almost always have my windows either all the
same size or the current one as big as possible.

the following function can be toggled on or off by typing <Leader>max (i can do
this quite quickly); just change the mapping at the bottom to something else if
you prefer.

this causes the current window to be as big as possible (moving into another
window causes that one to become big) and all the others get very small.  i
actually use this ALL the time.  turning it off (by typing the hotkey sequence
again) will cause all windows to have the same height.

"toggles whether or not the current window is automatically zoomed
function! ToggleMaxWins ()
  if exists ('g:windowMax')
    au! maxCurrWin
    exe "normal \<c-w>="
    unlet g:windowMax
  else
    augroup maxCurrWin
    " au BufEnter * exe "normal \<c-w>_\<c-w>\<bar>"
    "
    " only max it vertically
    au! BufEnter * exe "normal \<c-w>_"
    augroup END
    do maxCurrWin BufEnter
    let g:windowMax=1
  endif
endfunction
map <Leader>max :call ToggleMaxWins ()<CR>
%
i like bufdo and windo but i don't like the fact that the commands end in a
different window/buffer than from where i executed them.  these versions
(starts with a capital letter) will restore the current window or buffer when
the command's done.

for example, to turn on line numbers everywhere, i use :Windo set nu -- :windo
set nu does the trick also but leaves me in a different window than where i
started.

" just like windo but restores the current window when it's done
function! WinDo(command)
  let currwin=winnr()
  execute 'windo ' . a:command
  execute currwin . 'wincmd w'
endfunction
com! -nargs=+ -complete=command Windo call WinDo(<q-args>)

" just like bufdo but restores the current buffer when it's done
function! BufDo(command)
 let currBuff=bufnr("%")
 execute 'bufdo ' . a:command
 execute 'buffer ' . currBuff
endfunction
com! -nargs=+ -complete=command Bufdo call BufDo(<q-args>)
%
You can change the "View Source" editor of IE6 by adding the following to the
Windows Registry. Change the path in case you installed VIM in another
location.

[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source
Editor\Editor Name]
@="C:\\vim\\vim60\\gvim.exe"
%
Vim provides various commands and options to support editing multiple
buffers.  This document covers some of the questions asked about using
multiple buffers with Vim.  You can get more detailed information about Vim
buffer support using ":help windows.txt" in Vim.  You can also use the help
keywords mentioned in this document to read more about a particular command
or option.  To read more about a particular command or option use, ":help
<helpkeyword>" in Vim.

1. What is a Vim buffer?
   A buffer is a file loaded into memory for editing.  All opened files are
   associated with a buffer. There are also buffers not associated with any
   file.

   Help keyword(s): windows-intro

2. How do I identify a buffer?
   Vim buffers are identified using a name and a number.  The name of the
   buffer is the name of the file associated with that buffer.  The buffer
   number is a unique sequential number assigned by Vim.  This buffer
   number will not change in a single Vim session.

   Help keyword(s): :buffers

3. How do I create a buffer?
   When you open a file using any of the Vim commands, a buffer is
   automatically created.  For example, if you use the ":edit file" command
   to edit a file, a new buffer is automatically created.

4. How do I add a new buffer for a file to the buffer list without opening
   the file?
   You can add a new buffer for a file without opening it, using the
   ":badd" ex command.  For example,

       :badd f1.txt
       :badd f2.txt

   The above commands will add two new buffers for the files f1.txt and
   f2.txt to the buffer list.

   Help keyword(s): :badd

5. How do I get a list of all the existing buffers?
   You can get a list of all the existing buffers using the ":buffers" or
   ":ls" or ":files" ex command.  This list is called the 'buffer list'.

   In Vim 6.0, to display all the buffers including unlisted buffers, use
   the ":buffers!" or ":ls!" or ":files!" ex command.

   Help keyword(s): :buffers, :ls, :files

6. How do I delete a buffer?
   You can delete a buffer using the ":bdelete" ex command.  You can use
   either the buffer name or the buffer number to specify a buffer.  For
   example,

       :bdelete f1.txt
       :bdelete 4

   The above commands will delete the buffer named "f1.txt" and the fourth
   buffer in the buffer list.  The ":bdelete" command will remove the buffer
   from the buffer list.

   In Vim 6.0, when a buffer is deleted, the buffer becomes an
   unlisted-buffer and is no longer included in the buffer list.  But the
   buffer name and other information associated with the buffer is still
   remembered.  To completely delete the buffer, use the ":bwipeout" ex
   command.  This command will remove the buffer completely (i.e. the
   buffer will not become a unlisted buffer).

   Help keyword(s): :bdelete, :bwipeout

7. How do I delete multiple buffers?
   You can delete multiple buffers in several ways:

   1. Pass a range argument to the ":bdelete" command. For example,

           :3,5bdelete

      This command will delete the buffers 3, 4 and 5.
   2. Pass multiple buffer names to the ":bdelete" command.  For example,

           :bdelete buf1.txt buf2.c buf3.h

      This command will delete buf1.txt, buf2.c and buf3.h buffers.  In
      this example, after typing ":bdelete buf", you can press <Ctrl-A> to
      expand all the buffer names starting with 'buf'.

   Help keyword(s): :bdelete, :bwipeout

8. How do I remove a buffer from a window?
   You can remove a buffer displayed in a window in several ways:

   1. Close the window or edit another buffer/file in that window.
   2. Use the ":bunload" ex command. This command will remove the buffer
      from the window and unload the buffer contents from memory.  The
      buffer will not be removed from the buffer list.

   Help keyword(s): :bunload

9. How do I edit an existing buffer from the buffer list?
   You can edit or jump to a buffer in the buffer list in several ways:

   1. Use the ":buffer" ex command passing the name of an existing buffer
      or the buffer number.  Note that buffer name completion can be used
      here by pressing the <Tab> key.
   2. You can enter the buffer number you want to jump/edit and press the
      Ctrl-^ key.
   3. Use the ":sbuffer" ex command passing the name of the buffer or the
      buffer number.  Vim will split open a new window and open the
      specified buffer in that window.
   4. You can enter the buffer number you want to jump/edit and press the
      Ctrl-W ^ or Ctrl-W Ctrl-^ keys.  This will open the specified buffer
      in a new window.

   Help keyword(s): :buffer, :sbuffer, CTRL-W_^, CTRL-^

10. How do I browse through all the available buffers?
    You can browse through the buffers in the buffer list in several ways:

    1. To jump to the first buffer in the buffer list, use the ":bfirst" or
       ":brewind" ex command.
    2. To jump to the first buffer in the buffer list in a new window, use
       the ":sbfirst" or ":sbrewind" ex command.
    3. To edit the next buffer in the buffer list, use the ":bnext" ex
       command.
    4. To open the next buffer in the buffer list in a new window, use the
       ":sbnext" ex command.
    5. To edit the previous buffer in the buffer list, use the ":bprevious"
       or ":bNext" ex command.
    6. To open the previous buffer in the buffer list in a new window, use
       the ":sbprevious" or ":sbNext" ex command.
    7. To open the last buffer in the buffer list, use the ":blast" ex
       command.
    8. To open the last buffer in the buffer list in a new window, use the
       ":sblast" ex command.

    Help keyword(s): :bfirst, :brewind, :sbfirst, :sbrewind, :bnext,
                     :sbnext, :bprevious, :bNext, :sbprevious, :sbNext,
                     :blast, :sblast

11. How do I open all the buffers in the buffer list?
    You can open all the buffers present in the buffer list using the
    ":ball" or ":sball" ex commands.

    Help keyword(s): :ball, :sball

12. How do I open all the loaded buffers?
    You can open all the loaded buffers in the buffer list using the
    ":unhide" or ":sunhide" ex commands.  Each buffer will be loaded in a
    separate new window.

    Help keyword(s): :unhide, :sunhide

13. How do I open the next modified buffer?
    You can open the next or a specific modified buffer using the
    ":bmodified" ex command.  You can open the next or a specific modified
    buffer in a new window using the ":sbmodified" ex command.

    Help keyword(s): :bmodified, :sbmodified

14. I am using the GUI version of Vim (gvim), is there a simpler way for
    using the buffers instead of the ex commands?
    Yes.  In the GUI version of Vim, you can use the 'Buffers' menu, which
    simplifies the use of buffers.  All the buffers in the buffer list are
    listed in this menu.  You can select a buffer name from this menu to
    edit the buffer.  You can also delete a buffer or browse the buffer
    list.

    Help keyword(s): buffers-menu

15. Is there a Vim script that simplifies using buffers with Vim?
    Yes.  You can use the bufexplorer.vim script to simplify the process of
    using buffers.  You can download the bufexplorer script from:

        http://lanzarotta.tripod.com/vim.html

16. Is it possible to save and restore the buffer list across Vim sessions?
    Yes.  To save and restore the buffer list across Vim session, include
    the '%' flag in the 'viminfo' option.  Note that if Vim is invoked with
    a filename argument, then the buffer list will not be restored from the
    last session.  To use buffer lists across sessions, invoke Vim without
    passing filename arguments.

    Help keyword(s): 'viminfo', viminfo

17. How do I remove all the entries from the buffer list?
    You can remove all the entries in the buffer list by starting Vim with
    a file argument.  You can also manually remove all the buffers using
    the ":bdelete" ex command.

18. What is a hidden buffer?
    A hidden buffer is a buffer with some unsaved modifications and is not
    displayed in a window.  Hidden buffers are useful, if you want to edit
    multiple buffers without saving the modifications made to a buffer
    while loading other buffers.

    Help keyword(s): :buffer-!, 'hidden', hidden-buffer, buffer-hidden

19. How do I load buffers in a window, which currently has a buffer with
    unsaved modifications?
    By setting the option 'hidden', you can load buffers in a window that
    currently has a modified buffer.  Vim will remember your modifications
    to the buffer.  When you quit Vim, you will be asked to save the
    modified buffers.  It is important to note that, if you have the
    'hidden' option set, and you quit Vim forcibly, for example using
    ":quit!", then you will lose all your modifications to the hidden
    buffers.

    Help keyword(s): 'hidden'

20. Is it possible to unload or delete a buffer when it becomes hidden?
    The following works only in Vim 6.0 and above. By setting the
    'bufhidden' option to either 'hide' or 'unload' or 'delete', you can
    control what happens to a buffer when it becomes hidden.  When
    'bufhidden' is set to 'delete', the buffer is deleted when it becomes
    hidden. When 'bufhidden' is set to 'unload', the buffer is unloaded
    when it becomes hidden.  When 'bufhidden' is set to 'hide', the buffer
    is hidden.

    Help keyword(s): 'bufhidden'

21. How do I execute a command on all the buffers in the buffer list?
    In Vim 6.0, you can use the ":bufdo" ex command to execute an ex
    command on all the buffers in the buffer list.

    Help keyword(s): :bufdo

22. When I open an existing buffer from the buffer list, if the buffer is
    already displayed in one of the existing windows, I want Vim to jump to
    that window instead of creating a new window for this buffer.  How do I
    do this?
    When opening a buffer using one of the split open buffer commands
    (:sbuffer, :sbnext), Vim will open the specified buffer in a new
    window.  If the buffer is already opened in one of the existing
    windows, then you will have two windows containing the same buffer.
    You can change this behavior by setting the 'switchbuf' option to
    'useopen'.  With this setting, if a buffer is already opened in one of
    the windows, Vim will jump to that window, instead of creating a new
    window.

    Help keyword(s): 'switchbuf'

23. What information is stored as part of a buffer?
    Every buffer in the buffer list contains information about the last
    cursor position, marks, jump list, etc.

24. What is the difference between deleting a buffer and unloading a
    buffer?
    When a buffer is unloaded, it is not removed from the buffer list.
    Only the file contents associated with the buffer are removed from
    memory.  When a buffer is deleted, it is unloaded and removed from the
    buffer list.  In Vim 6, a deleted buffer becomes an 'unlisted' buffer.

    Help keyword(s): :bunload, :bdelete, :bwipeout, unlisted-buffer

25. Is it possible to configure Vim, by setting some option, to re-use the
    number of a deleted buffer for a new buffer?
    No.  Vim will not re-use the buffer number of a deleted buffer for a
    new buffer.  Vim will always assign the next sequential number for a
    new buffer.  The buffer number assignment is implemented this way, so
    that you can always jump to a buffer using the same buffer number.  One
    method to achieve buffer number reordering is to restart Vim.  If you
    restart Vim, it will re-assign numbers sequentially to all the buffers
    in the buffer list (assuming you have properly set 'viminfo' to save
    and restore the buffer list across vim sessions).

    Help keyword(s): :buffers

26. What options do I need to set for a scratch (temporary) buffer?
    The following works only in Vim 6.0 and above.  You can set the the
    following options to create a scratch (temporary) buffer:

        :set buftype=nofile
        :set bufhidden=hide
        :setlocal noswapfile

    This will create a buffer which is not associated with a file, which
    does not have a associated swap file and will be hidden when removed
    from a window.

    Help keyword(s): special-buffers, 'buftype'

27. How do I prevent a buffer from being added to the buffer list?
    The following works only in Vim 6.0 and above. You can prevent a buffer
    from being added to the buffer list by resetting the 'buflisted'
    option.

        :set nobuflisted

    Help keyword(s): 'buflisted'

28. How do I determine whether a buffer is modified or not?
    There are several ways to find out whether a buffer is modified or not.
    The simplest way is to look at the status line or the title bar.  If
    the displayed string contains a '+' character, then the buffer is
    modified.  Another way is to check whether the 'modified' option is set
    or not.  If 'modified' is set, then the buffer is modified.  To check
    the value of modified, use

        :set modified?

    You can also explicitly set the 'modified' option to mark the buffer as
    modified like this:

        :set modified

    Help keyword(s): 'modified'

29. How can I prevent modifications to a buffer?
    The following works only in Vim 6.0 and above. You can prevent any
    modification to a buffer by re-setting the 'modifiable' option.  To
    reset this option, use

        :set nomodifiable

    To again allow modifications to the buffer, use:

        :set modifiable

    Help keyword(s): 'modifiable'

30. How do I set options specific to the current buffer?
    The following works only in Vim 6.0 and above.  You can set Vim options
    which are specific to a buffer using the "setlocal" command.  For
    example,

        :setlocal textwidth=70

    This will set the 'textwidth' option to 70 only for the current buffer.
    All other buffers will have the default or the previous 'textwidth'
    value.

    Help keyword(s): 'setlocal', local-options

31. How do I define mappings specific to the current buffer?
    The following works only in Vim 6.0 and above.  You can define mappings
    specific to the current buffer by using the keyword "<buffer>" in the
    map command.  For example,

        :map <buffer>  ,w  /[.,;]<CR>

    Help keyword(s): :map-local

32. How do I define abbreviations specific to the current buffer?
    The following works only in Vim 6.0 and above.  You can define
    abbreviations specific to the current buffer by using the keyword
    "<buffer>" in the :abbreviate command.  For example,

        :abb <buffer> FF  for (i = 0; i < ; ++i)

    Help keyword(s): :abbreviate-local
%
Since I installed Win2K on my laptop, I had been unable to locate a utilitie
that would simply enable me to remap my Crtl Alt and Caps the way I think they
should be and the way they were until MS kill all competition in computing,
that is Crtl on the left of the letter A, Alt to the left bottom of the letter
Z and Caps approximately until the C.

After some research, I came across a tip posted here by juano@mindspring.com. I
tried to make sense of it and then downloaded the MS scan keys map at the URL
he mentionned.

Extrapolating his tip, I wrote this ASCI file that I named keys2000.reg :


Regedit4
[HKey_Local_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode
Map"=hex:00,00,00,00,00,00,00,00,04,00,00,00,3A,00,38,00,38,00,1D,00,1D,00,3A,00,00,00,00

Once you have saved this file, left click on it from Explorer and answer yes to
the prompt "do you want to enter this into the registry".

Reboot and you are done.

A few explanations :04 stands for 3 remappings (Caps lock to Control, Control
to Alt and Alt to Caps Lock) plus the closing one which is always required (1
remapping would require 02, 2 would require 03, and so on). 3A,00,38 remaps
Caps to Left Alt, 38,00,1D remaps Left Alt to Left Ctrl and 1D,00,3A remaps
Left Ctrl to Caps Lock since 3A=Caps, 1D=Left Ctrl and 38=Left Alt.

Based on Juano tip and on this one, I believe a lot of remapping can be done as
long as you keep the separators 00 and remember to add one to the number of
remappings. What I do not know is how far you can extend this instruction
without getting into trouble with the registry. At worst, if you keyboard does
not behave as expected, go into the registry and delete this instruction (be
careful here since it is easy to confuse this instruction with the Keyboard
LayoutS (S for emphasis) which must not be deleted.

Again, thanks to Juano@mindspring.com who got me going and suggested I post my
tip. Took me some time to retrieve the VIM Url but fortunately, I had printed
his tip.

Regards
%
I hate it when I hit left (or h) and my screen flickers.  I want it to go up to
the next line.  Ditto fir right (or l).  Below are two functions / mappings to
help with that.  I'm pretty sure that if you remove the <silent>, then it will
work in 5.x...

nnoremap <silent> <Left>  :call WrapLeft()<cr>
nnoremap <silent> <Right> :call WrapRight()<cr>

nnoremap <silent> h       :call WrapLeft()<cr>
nnoremap <silent> l       :call WrapRight()<cr>

function! WrapLeft()
    let col = col(".")
    
    if 1 == col
        " don't wrap if we're on the first line
        if 1 == line(".")
            return
        endif
        normal! k$
    else
        normal! h
    endif
endfunction

function! WrapRight()
    let col = col(".")
    if 1 != col("$")
        let col = col + 1
    endif
        
    if col("$") == col
        " don't wrap if we're on the last line
        if line("$") == line(".")
            return
        endif
        normal! j1|
    else
        normal! l
    endif
endfunction
%
Hi All,
 
While browsing code one always needs to know which function you are currently
looking. Getting the name is very painful when the functions are lengthy and
you are currently browsing NOT near to the start of the function. You can get
the function's name by using this simple mapping.
 
Just place this in your .vimrc.
 
map _F ma[[k"xyy`a:echo @x<CR>
 
now _F will display which function you are currently in.
 
Enjoy the power of Vim
-Nitin Raut

PS: The working is as follows, mark the current line with a, jump to the
previous '{' in the first column, go one line up, yank the line in register x,
return to the mark a, echo the value of register x, which is the wanted
function name.                  
%
Check out

http://www.erols.com/astronaut/vim/textab.html

and see some examples of text alignment (its hopeless to do it here with
proportional fonts).  You'll be able to download textab source, a Windows-based
textab executable, and a scriptfile containing a convenient interface
(ttalign.vim).  The textab program coupled with <ttalign.vim> lets you:

1. align C language statements on their = += -= /= etc symbols
2. align C language declararations: separate columns for types, *[, variable
   names, initializations (=), and comments (// or /* .. */)
3. align C/C++ language comments (//, /* .. */)
4. align C/C++ language (ansi) function argument lists
5. align LaTeX tables on their && separators
6. align HTML tables with </TD><TD> separators
7. align on several characters: < ? : | @ ;  (or modify them to handle whatever
   alignment characters you want)
%
When writing scripts using the embedded interpreter available if vim has the
+perl ore +perl/dyn on 
gives you access to this powerfull and FAST scripting language (especially fast
compared to vim 
scripts)  there are some gotchas.

First:
never embed complex perl command in the body of a vim function this will be
recompiled and evaled
each time for a tremendous loss of time.instead to it like this

perl << EOF
sub mySub
{
  #some usefull perl stuff
}
EOF

function! MyFunction
perl mySub "an argument", "another"
endfunction

to pass computed argument to your perl sub use the vim exec command
function! MyFunction
exec "perl mySub " . aLocalVar . ", " b:aBufferLocalVar
endfunction

It may be very hard to debug your perl sub since the output of the perl compiler is
somehow lost in the middle of nowhere and the debugger is not available.
When a compilation error occurs in your sub definition you'll get an error message
when you try to call it saying that the sub does not exists.
One thing which I have found very usefull is to write a fake VIM module with stub 
methods which will allow you to use the command line perl interpretor to at least
compile your program.  You could make your stub smart enough to fake a vim
and use the debugger.  Here is a sample for such a fake module defining just
those method which I was using.

package VIM;
use diagnostics;
use strict;
sub VIM::Eval
{
	$_ = shift;
	
	print "Eval $_\n";
	
	{
		  return '^(?!!)([^\t]*)\t[^\t]*\t(.*);"\t([^\t]*)\tline:(\d*).*$' if
		  (/g:TagsBase_pattern/);
		  return $ARGV[0] if (/b:fileName/);
		  return '$3' if (/g:TagsBase_typePar/);
		  return '$1' if (/g:TagsBase_namePar/);
		  return '$4' if (/g:TagsBase_linePar/);
		  return 'Ta&gs' if (/s:menu_name/);
		  return $ARGV[1] if (/g:TagsBase_groupByType/);
		die "unknown eval $_"; 
	}  
}
sub VIM::Msg
{
	my $msg = shift;
	print "MSG $msg\n";
}
sub VIM::DoCommand
{
	my $package;
	my $filename;
	my $line;
    ($package, $filename, $line) = caller;
	
	my $command = shift;
	print "at $filename $line\n";
	print "DoCommand  $command\n";
}
1;


Then you can copy other your perl code in a separate file and add a use VIM; at
the top
and your set to debug.

Good Vimming good perling.
Benoit
PS:
this tips are probably true for other scripting languages
%
Below is a tip that the C/C++ Newbies may find interesting and handy to use.
The following code will add a function heading and position your cursor just
after Description so that one can document as one proceeds with code.

function FileHeading()
	let s:line=line(".")
	call setline(s:line,"/***************************************************")
	call append(s:line,"* Description - ")
	call append(s:line+1,"* Author -      Mohit Kalra")
	call append(s:line+2,"* Date -        ".strftime("%b %d %Y"))
	call append(s:line+3,"* *************************************************/")
	unlet s:line
endfunction

imap <F4>  <esc>mz:execute FileHeading()<RET>`zjA

Where <esc> stands for ^V+ESC and <RET> for ^V+ENTER
%
Some people have a habit of adding the function name as a comment to the end of
that function, if it is long, so that he/she knows which function the '}' ends.
Here's a way to automate the process.

Use the following abbreviation:
iab }// } // END: <esc>10h%$?\w\+\s*(<cr>"xy/\s*(<cr>/{<cr>:nohl<cr>%$"xpa

If you now end the function with '}//', the follwoing string will be
automatically generated: '} //END: functionname'
%
Hi,

The fold-method marker can be effectively use to set the folds in your Java
source.  Define some marker and place it inside HTML comments <!-- xx -->.
This way, it does not affect the Javadocs generated without the necessity of a
seprate comment line.
e.g.


/**
 * <!-- zz.FOLDSTART class AbcClass -->
 * The class description.
 * ...
 */
public class AbcClass {

    /**
     * <!-- method zz.FOLDSTART someMethod() -->
     * Method description.
     */
    public void someMethod();

    ...

} /* zz.END: AbcClass */

/* Put this at the end of your file */
/* vim:fdm=marker fmr=zz.FOLDSTART,zz.END fdl=2 fdc=2: */

Now, the files will be opened with the methods neatly folded.
You can use "zR" to open all folds (or click on the "+" at the left column).

Sameer.
%
The most useful feature that I find in VIM is the "recording" feature (:help
recording).  I have used this to automatically insert function headers,
re-indent lines, and convert some 34 source files into HTML.

This feature is most useful when you want to do some repeated jobs, which you
cant do easily using ".".  You can set about writing a function, define a
mapping, etc, but then these things might take time.  By recording, you can try
out and find the actual keystrokes that does the job.

To start recording, press "q" in normal mode followed by any of "0-9a-z".  This
will start recording the keystrokes to the register you choose.  You can also
see the word "recording" in the status(?) line.  You can start the key
sequences that you want to record.  You can go to insert mode and type if you
want.

To stop recording, press "q" in the normal mode.

To playback your keystrokes, press "@" followed by the character you choose.
Pressing "@@" will repeat the same again.

Sameer.
%
Those of us doomed to work in both the Unix and Windows world have many times
encountered
files that were create/editted on systems other that the one we are on at the
time of our edits.  We
can easily correct the dreaded '^M' at the end of our Unix lines, or make files
have more than one
line in DOS by:

To change from <CR><LF> (DOS) to just <LF> (Unix):
:set fileformat=unix
:w

Or to change back the other way:
:set fileformat=dos
:w

It also works for Apple land:
:set fileformat=mac
:w


And to tell the difference:
set statusline=%<%f%h%m%r%=%{&ff}\ %l,%c%V\ %P
											  ^^^^^  This shows what the
											  current file's format is.

Happy Vimming!
%
i use the :split command a lot -- both to open a second window containing the
currently edited file and to edit a new file altogether (with the :split
<filename> option).  however, i also like to be able to edit more than one file
and calling :sp multiple times is inconvenient.  so, i created the following
command, function and abbreviation:

function! Sp(...)
  if(a:0 == 0)
    sp
  else
    let i = a:0
    while(i > 0)
      execute 'let file = a:' . i
      execute 'sp ' . file

      let i = i - 1
    endwhile
  endif
endfunction
com! -nargs=* -complete=file Sp call Sp(<f-args>)
cab sp Sp


this retains the behaviour of :sp in that i can still type :sp (the
abbreviation takes care of that).  :Sp takes any number of files and opens them
all up, one after the other.

the things i have noticed are that this causes 'sp' to be expanded to 'Sp'
everywhere, even in search patterns.  also, prepending 'vert' doesn't work.  if
there is interest, i'll do that.
%
This tip gives a skeleton for writing a plugin; Vim's help files have plenty
of details (:he plugin, :he write-plugin, :he plugin-details).

# ------------------------------------------------------------------------------
# Exit when your app has already been loaded (or "compatible" mode set)
if exists("loaded_YourAppName") || &cp
  finish
endif

# Public Interface:
#  AppFunction: is a function you expect your users to call
#  PickAMap: some sequence of characters that will run your AppFunction
# Repeat these three lines as needed for multiple functions which will
# be used to provide an interface for the user
if !hasmapto('<Plug>AppFunction')
  map <unique> <Leader>PickAMap <Plug>AppFunction
endif

# Global Maps:
#  
map <silent> <unique> <script> <Plug>AppFunction 
\ :set lz<CR>:call <SID>AppFunc<CR>:set nolz<CR>

# ------------------------------------------------------------------------------

# AppFunction: this function is available vi the <Plug>/<script> interface above
fu! <SID>AppFunction()
..whatever..

# your script function can set up maps to internal functions
nmap <silent> <left> :set lz<CR>:silent! call <SID>AppFunction2<CR>:set nolz<CR>

# your app can call functions in its own script and not worry about name
# clashes by preceding those function names with <SID>
call <SID>InternalAppFunction(...)

# or you could call it with
call s:InternalAppFunction(...)
endf
# ------------------------------------------------------------------------------

# InternalAppFunction: this function cannot be called from outside the
#  script, and its name won't clash with whatever else the user has loaded
fu! <SID>InternalAppFunction(...)
..whatever..
endf

# ------------------------------------------------------------------------------

Plugins are intended to be "drop into <.vim/plugin>" and work.  The problem
that the <Plug>, <SID>, etc stuff is intended to resolve: what to do about
functions that have the same names in different plugins, and what to do about
maps that use the same sequence of characters?  The first problem is solved
with <SID> (a script identifier number) that vim assigns: program with it and
your users will be happier when your stuff works with all their other stuff.
The second problem: what to about those maps is addressed with <Plug>, <unique>,
etc.  Basically the idea is: let the user know that there are clashes and don't
overwrite previously existing maps.  Use the user's preferred map-introducer
sequence (I like the backslash, but there are many keyboards which make
producing backslashes unpleasant, and those users usually prefer something
else).

What I like to do is to have a pair of start/stop maps to reduce my impact on
the namespace.  When the starting map is used, it kicks off a starting function
that introduces all the maps needed.  When the stopping map is used, it not
only removes the maps the starter made but restores any maps the user had had
that would have clashed.  I also use the start/stop pair of functions to set
and restore options that cause my scripts difficulties.

Check out DrawIt.vim's SaveMap() function for a way to save user maps.
Restoring maps with it is easy:

if b:restoremap != ""
 exe b:restoremap
 unlet b:restoremap
endif

So you can see it sets up a string variable with all the maps that the user
had that would have clashed with my application.

One final thing: if your application needs to share information between its
various functions, see if you can use s:varname (a variable that only your
script's functions can access) or b:varname (a variable that anything associated
with the buffer your application is running with can access) instead of using
global variables.

Good luck and happy Vimming!
%
Accidently discovered that using <alt><Menu Hotletter><cr> (e.g <alt>b<cr> -
for the buffer menu) causes the menu to break out in a seperate window.  
Selecting the menu with the mouse and then hitting enter does not seem to do it. 

I will have to learn to add hotletters to my menus now so that the mouse can
take a break.

I am a total newbie with vim, but constantly amazed.... 
%
When trying to reconcile differences between files, and using the new
'diff' functionality in Vim 6.0 you may want to automatically update
the differences as you are working along.  A convienent time is when you
write out either of the files you are diff'ing.  This autocmd will take
care of doing that for you.


" If doing a diff.  Upon writing changes to file, automatically update the
  " differences
  au BufWritePost                  *              if &diff == 1
  au BufWritePost                  *              :diffupdate
  au BufWritePost                  *              endif
%
You can use the "Visual Incrementing" script from

  http://www.erols.com/astronaut/vim/index.html#VimFuncs

to convert a block of numbers selected via ctrl-v (visual block)
into a column of increasing integers.  Select the column, press :I<CR>,
and the first line's number will be used as a starting value.  Subsequent
lines's numbers will be incremented by one.

If the ctrl-v block is "ragged right", which can happen when "$" is used
to select the right hand side, the block will have spaces appended as
needed to straighten it out.  If the strlen of the count exceeds the
visual-block allotment of spaces, then additional spaces will be inserted.

Example:  Put cursor on topmost zero, select column with ctrl-v, then :I

   vector[0]= 1;       vector[0]= 1;
   vector[0]= 1;       vector[1]= 1;
   vector[0]= 1;  -->  vector[2]= 1;
   vector[0]= 1;       vector[3]= 1;
   vector[0]= 1;       vector[4]= 1;

This script works with both vim 5.7 (:so visincr.vim) or vim 6.0 (source it
as for vim 5.7 or drop it into the .vim/plugin directory).
%
There is an ascii table in the vim-help files, but it's hard to find.  Thus, I
shall give a pointer to it:

:help digraph-table
%
Under http://www.erols.com/astronaut/vim/index.html#vimlinks_scripts
are links to spelling checkers for Dutch, English, German, Hungarian,
and Yiddish, all based on the original engspchk.vim.  The spelling
checker provides as-you-type spell checking; with vim6.0 it will avoid
checking on partially typed words.

Provided are several maps:

  \et : add  word under cursor into database for just this file
  \es : save word under cursor into database (permanently)
  \en : move cursor to the next     spelling error
  \ep : move cursor to the previous spelling error
  \ea : look for alternative spellings of word under cursor

To use \ea you will need agrep:

  agrep source: ftp://sunsite.unc.edu/pub/Linux/utils/text/agrep-2.04.tar.Z
  agrep Win exe: http://www.tgries.de/agrep

To use the spell checkers just source it in:

  ex.  so engspchk.vim

To read more about it see

  http://www.erols.com/astronaut/vim/index.html#Spelling
%
1) ++++++++++++++++++++++++++ "Automatic" bracket setting
+++++++++++++++++++++++++++++
2) +++++++++++++ Further improvement of parenthesis/bracket expanding
+++++++++++++++++
3) ++++++++++++++++++++++++++++ "Late" bracketing of text
+++++++++++++++++++++++++++++
4) +++++++++++++++++++++++++++++ Conclusion
++++++++++++++++++++++++++++++++++++++ ++++

=======================================================================================

1) ++++++++++++++++++++++++++ "Automatic" bracket setting
+++++++++++++++++++++++++++++ 

To automatically insert a closing parenthesis when typing an opening
parenthesis you can insert the following simple mapping to your vimrc:

	:inoremap ( ()<ESC>i

This ends up with the cursor between the opening and the closing parenthesis
in insert mode.

You can apply this and the following tips, of course, with the kind of
parenthesis/bracket
character you want to, i.e. (, {, [, < ..... and, pretty useful as well,
quotation marks ",',.... (to be continued)

2) +++++++++++++++ Further improvement of parenthesis/bracket expanding
++++++++++++++++++

I you are ready with filling the parenthesis/brackets, you likely want to
"escape" from the brackets again to continue coding.
To make this pretty comfortable, I invented the following kind of mappings,
which get out
of the last expanded parenthesis/bracket, regardless of the actual type of it, and
enter append mode again.
I mapped this kind of "getaway" with CTRL_j, you may use your favorite
keystroke with it.

			...
	:inoremap ( ()<ESC>:let leavechar=")"<CR>i
	:inoremap [ []<ESC>:let leavechar="]"<CR>i
			...
	:imap <C-j> <ESC>:exec "normal f" . leavechar<CR>a

Explanation: The variable "leavechar" contents the actual char which is to
"escape" from.


3) ++++++++++++++++++++++++++++ "Late" bracketing of text
+++++++++++++++++++++++++++++

Occasionally I later want already written text parts to put in parenthesis.

I use the following macro, which brackets previously visually selected text.
I mapped it with _(.

	:vnoremap _( <ESC>`>a)<ESC>`<i(<ESC>

Furthermore, a sort of mapping for bracketing a *single word* is conceivable.
Because this is not as general like the kind of visual mode mapping, I use
this kind of "word bracketing" only for surrounding the word right behind the
cursor in insert mode with **.  I use the following macro to "emphasize" the
word i just typed,
for newsgroup articles.

	:imap _* <Esc>bi*<Esc>ea*<Space>


4) ++++++++++++++++++++++++++++++ Conclusion
++++++++++++++++++++++++++++++++++++++++++

Since I use these macros, I never caused a syntax error because of missing
brackets, and furthermore I can quickly insert parenthesis and qutotes into code-
and non-code files.

 JH 04.11.2001
%
" 
" Mappings to facilitate the creation of text
"
" Author:  Suresh Govindachar sgovindachar@yahoo.com
" Date:     November 5, 2001
"
" While typing text to create a document, I often end up hitting
" <Esc>, issuing some commands (with or without ":") and getting back 
" to typing by issuing a command such as "i", "O", "s" etc.
"
" I looked into using "set insertmode" to speed up such actions, but
" found that too confusing. 
"
" I have come up with a set of mappings that have speeded up my process
" of creating documents.  I have saved these mappings in a file, named
" FullScreenVI.vim, in vim's plugin directory.
"
" Perhaps you will find these mappings helpful too.
"
" Please send me feedback.  
" 

"To allow overriding the Alt key
set winaltkeys=no  
"To enable viewing messages from commands issued using the mappings presented here 
set cmdheight=2    

"The fundamental mapping that makes full-screen editing possible
imap <A-o>  <C-o>
imap <A-;>  <C-o>:

"Basic motions
imap <A-h>  <Left>
imap <A-j>  <Down>
imap <A-k>  <Up>
imap <A-l>  <Right>
imap <A-f>  <PageDown>
imap <A-b>  <PageUp>
imap <A-^>  <Home>
imap <A-$>  <End>

"Numbers for repeats
imap <A-1>  <C-o>1
imap <A-2>  <C-o>2
imap <A-3>  <C-o>3
imap <A-4>  <C-o>4
imap <A-5>  <C-o>5
imap <A-6>  <C-o>6
imap <A-7>  <C-o>7
imap <A-8>  <C-o>8
imap <A-9>  <C-o>9

"Basic searches
imap <A-/>  <C-o>/
imap <A-*>  <C-o>*
imap <A-#>  <C-o>#
imap <A-n>  <C-o>n
imap <A-N>  <C-o>N

"Deleting
imap <A-x>  <C-o>x
imap <A-d>  <C-o>d
imap <A-D>  <C-o>D

"Yanking and putting
imap <A-y>  <C-o>y
imap <A-Y>  <C-o>Y
imap <A-p>  <C-o>p
imap <A-P>  <C-o>P

"Common prefixes:  marking, matching etc.
imap <A-~>  <C-o>~
imap <A-m>  <C-o>m
imap <A-`>  <C-o>`
imap <A-">  <C-o>"
imap <A-%>  <C-o>%
imap <A-h>  <C-o>:h
imap <A-s>  <C-o>:s

"Interacting with the 'outside'
imap <A-!>  <C-o>:!
imap <A-w>  <C-o>:w<CR>
imap <A-e>  <C-o>:e

"Other commands
imap <A-u>  <C-o>u
imap <A-.>  <C-o>.
%
Here's a plugin to automatically decompile Java .class files as they're read
in.  Tweak the javap flags for what you want to see.  I didn't post this as a
script because it's too simple and it's really more useful for demonstrating
how to read decompilable files (or other binary files that can be converted to
text).

function s:ReadClass(dir, classname)
    execute "cd " . a:dir
    execute "0read !javap -c " . a:classname
    1
    setlocal readonly
    setlocal nomodified
endfunction


autocmd BufReadCmd *.class
    \ call <SID>ReadClass(expand("<afile>:p:h"), expand("<afile>:t:r"))
%
i had some trouble with the sqlplus scripts (probably my fault).  but it seemed
a little heavy for what i need, usually all i want is a listing of the columns
for a given table while i'm whipping on some sql inside vim.

so i wrote a bash script (describe)...

~~~~~~~~~~~~~~~begin describe script
#!/usr/bin/bash

f=aTempFile.sql
u=<uName>
p=<pWord>
d=<dBase>

echo "/* describe for $1"
echo "describe $1;" > $f;
echo "quit;" >> $f;

sqlplus -S $u/$p@$d @$f
rm -f $f;
echo " end describe for $1 */"
~~~~~~~~~~~~~~~end describe script

your path needs to include the script (as well as sqlplus), then from vim you
can just type....

:r !describe <tableName>

and you get a listing of the table columns slammed into wherever your cursor
was, complete with java/c comments
%
if you get away from vim and get any other editor that was built *after* 1970....
%
If you really like the Computer Modern typewriter font (as seen in most TeX
distributions) you can use it as the font in gvim! (looks excellent with font
smoothing turned on)

First, get hold of the free Blue Sky Type 1 PS versions of the CM fonts from
your local CTAN mirror. Unpack to a suitable directory.

Next locate the cmtt8.pfb file and open it (in Vim, naturally ;) - find the line
saying
dup 32 /visiblespace put

and change it to
dup 32 /space        put

that is, inserting enough spaces to keep the file size exactly the same
(IMPORTANT!)

Save the file in Mac format (:set fileformat=mac).

Now install the cmtt.pfm file - in Win9x/NT4, you'll need Adobe Type Manager
(free download), but in Win2k, you can just drop the .pfm file into the Fonts folder.

Now in your _gvimrc:
set guifont=CMTT8:h11:cSYMBOL

(use whatever height you like instead of h11)

..and enjoy! It's the first scalable font I can bear to edit code in... %-)
%
1) ++++++++++++++ Saving Keystrokes for common Searching and Substituting +++++++++++
--- a) Searching  b) Substituting ---------------------------------------------------
2) ++++  Searching for resp. Substituting of the current word under the cursor ++++++
--- a) Searching  b) Substituting ---------------------------------------------------
3) ++ Searching and Substituting for an arbitrary visually selected part of text ++++
--- a) Searching  b) Substituting ---------------------------------------------------
4) ++++++++++++++++++++++++++++++++  Conclusion +++++++++++++++++++++++++++++++++++++

=====================================================================================

1) ++++++++++++++ Saving Keystrokes for common Substituting and Searching +++++++++++

a) Searching ............
Sorry, there is not much that can be saved for common Searching. It's just hitting
/mypattern<RETURN> 

b) Substituting .........
I think, common substitution requires pretty many keystrokes. So I use the
following macro with my favorite substitution options:

:map <F4> :%s//gc<Left><Left><Left>

This ends up with the cursor after the first '/' in the commandline. To complete it,
you only have to enter
->	myoldpattern/mynewpattern<RETURN>

Remark: I mapped it to <F4> (cause of tribute to the <F4> of the good old Norton
Commander editor). You may map it where you want to.


2) ++++  Searching for resp. Substituting of the current word under the cursor ++++++

a) Searching ............
If you don't know how to look for the next occurence of the word under the
cursor, you
should *now* type
:help * or
:help star
or refer to the tips vimtip #1 or vimtip #5
((Tip within tip: To make your pattern more visible, look for :help hls))

b) Substituting .........
The following macro extends the one above with automatically inserting the
current word
under the cursor into the from - pattern of the :s command.

:map <S-F4> :%s/<C-r><C-w>//gc<Left><Left><Left>

To complete it, just enter
->	mynewpattern<RETURN>

I use this i.e. for reliable and quickly renaming a variable in the entire buffer.
I mapped it to Shift-<F4>. You may map it to the keystroke you want.

Explanation: CTRL-v+CTRL-w expands to the word under the cursor.


3) ++ Searching and Substituting for an arbitrary visually selected part of text ++++

If you want to look or substitute (for) an *arbritary* pattern (which already
exists at
least once in your text), the following 2 mappings do it for you.
The advantage is that you dont have to type again or cut & paste the appropriate text
but only have to visually select it.

a) Searching ...........

:vmap / y:execute "/".escape(@",'[]/\.*')<CR>

This immediately finds to the next occurence of the previously visually
selected text.


b) Substituting .........

:vmap <F4> y:execute "%s/".escape(@",'[]/\')."//gc"<Left><Left><Left><Left>

Again, as in the mapping in chapter 2), you just have to complete it by entering
-> mynewpattern<RETURN>

Explanation/Discussion:
What both Substituting and Searching in this way generally does is:
- *y*anking the selected text
- Inserting the visually selected via adressing the '"' register with '@"' as a
  parameter of the escape() function going finally into the 'myoldpattern' part.
  The trickery problem is, if you have characters in your myoldpattern, which are
  regular expression chars, they are recognized and threated accordingly.  That
  is most likely not what you wanted.  To escape them, these chars have to be
  declared by the second parameter of the excape() function, which then escapes them
  with a backslash.  The few characters above work for me. If you run into problems,
  you should check for additional regexp chars in your text, and try to escape them
  by adding them to the escape() function parameter.


4) ++++++++++++++++++++++++++++++++  Conclusion +++++++++++++++++++++++++++++++++++++

With the appropriate mappings in your vimrc you can save keystrokes when Searching or
Substituting and avoid typing errors. That way, you can take lunch sooner
%
Download at http://www.thomer.com/thomer/vi/nlspchk.vim.gz.

This sciript is based on Charles E. Campbell's English spelling checker script
for ViM (http://users.erols.com/astronaut/vim/) and Piet Tutelaers' Dutch word
list (http://www.ntg.nl/spell-nl-v5b/) using  Thomas Köhler's script
(http://jeanluc-picard.de/vim/gerspchk/create). In other words, I didn't do
much.
%
Several plugins use a text base interface based on a special buffer, this is
the case of the standard explorer plugin, several bufexplorer plugins, the
option buffer and others...
Here is a quick guide in how to do this


Writing a special buf script
	| using a special buffer is a common technic when writing Vim scripts, it is used by
	| explorer, bufexplorer, DirDiff...
	| I'm currently writing one for TagsBase.vim 
	| http://vim.sourceforge.net/scripts/script.php?script_id=100 
	| and I'll use this document to take notes on how to do it.
	| 

Setting up the buffer
	Opening the window TODO

	Using a setup function
		Principle
			| we can use a specific function to open and setup the special
			buffer. s:SetupBuf()
		Setup Function advantage
			| since the command will be defined in the main script you
			| can use script local functions
	Using a special filetype
		Principle
			| we can also use a new filetype and distribute a syntax and an ftplugin for this 
			| filetype, the only thing needed in this case is to set the
			| filetype after creating the buffer
		Filetype advantage
			| better separations of different parts of your script. If
			| the main function of your plugin is not to have this
			| special buffer then it is nice to avoid clutering it.
	Things which needs to be done to setup the buffer
		The buffer should not be listed and does not correspond to a file
			* setlocal buftype=nofile
			-	options always local to buffer
			* set nobuflisted 		
			* set bufhidden=delete
			* set nomodifiable
		Setup the syntax for this buffer
			| see :help syntax
			| This is usually done in two steps, first describe the
			| syntax groups using :syn commands then setup the
			| hilighting using :hi def link commands.  Usually it is
			| best to link the newly defined groups to predefine ones in
			| order to make the coloring work fine with colorschemes.
			| You'll find the list of predefined group by doing:
			| :help group-name
		Setup the special mappings
			| since we have chosen to use the set nomodifiable option
			| our buffer will never be in insert mode. All our mapping
			| are in Normal, Visual or operator pending, they should
			| therefore use the map, nmap, vmap and omap mapping command
			| plus the associated 'nore' version.  I usually find it
			| better to use the 'nore' version to avoid surprises due to
			| mapping in the user configuration.
			|
			| We also want our mappings to be local to the special
			| buffer so all the commands will use the <buffer> modifier.
			|
			| Finally we want our mappings not to polute the status bar
			| so we use the <silent> modifier
			| 
			| Putting all this together we end up with mapping commands
			| which look like:
			| noremap <buffer> <silent> {lhs} {rhs}
		Setup the special command
			| we will then setup special commands for this buffer.  Like
			| for the mapping there are some precautions to take:
			| we don't want an error message if the command is defined
			| twice so we use the command! variant.
			| We want a command local to our buffer wo we use the
			| -buffer attribute.  The rests of the command attributes
			|  and options depend on the actual command.
			|  So our commands look like:
			|  command! -buffer {attr} {cmd} {rep}
			|  where attr is optional.
%
" Map H to toggle search highlighting
map H :let &hlsearch = !&hlsearch<CR>
%
I had a problem with VIM on the FreeBSD console: it didn't display characters
like German umlauts correctly, but escaped them with a tilde. The solution is
to teach VIM about printable characters. I use the following on my .vimrc:

set isprint=@,128-255
%
I'm not sure if this functionality is already within Vim, but I sometimes I
find it useful to keep a split window from closing when deleting a buffer.
This has already been discussed on the vim@vim.org mailing list.  However, I
feel this solution is a little easier to use.


" Put this into .vimrc or make it a plugin.
" Mapping :Bclose to some keystroke would probably be more useful.
" I like the way buflisted() behaves, but some may like the behavior
" of other buffer testing functions.

command! Bclose call <SID>BufcloseCloseIt()

function! <SID>BufcloseCloseIt()
	let l:currentBufNum = bufnr("%")
	let l:alternateBufNum = bufnr("#")

	if buflisted(l:alternateBufNum)
		buffer #
	else
		bnext
	endif

	if bufnr("%") == l:currentBufNum
		new
	endif

	if buflisted(l:currentBufNum)
		execute("bdelete ".l:currentBufNum)
	endif
endfunction
%
(This originally appeared on the vim mailing list as post by Adam Monsen
http://groups.yahoo.com/group/vim/message/19856)

If you want to completely swap caps lock and escape, you have to replace the 
"Lock" on caps lock. Drop this file in your home dir:<br>
-----------start------------<br>
! Swap caps lock and escape<br>
remove Lock = Caps_Lock<br>
keysym Escape = Caps_Lock<br>
keysym Caps_Lock = Escape<br>
add Lock = Caps_Lock<br>
------------end-------------<br>
and call it ".speedswapper". Then open a terminal and type<br>
$ xmodmap .speedswapper<br>
and you'll be twice as efficient in vim. Who needs caps lock anyway? The
swapping lasts for the duration of the X session, so you can put it in a
.xinitrc or similar startup file. As far as other people using my laptop, I'd
rather they didn't! Using a Dvorak layout might protect me even more... :)
%
To use vim as a man-page viewer involves setting an environment variable:

    sh, ksh:  export MANPAGER="col -b | view -c 'set ft=man nomod nolist' -"
    csh    :  setenv MANPAGER "col -b | view -c 'set ft=man nomod nolist' -"

Put one of the above two lines into your <.profile> or <.login> file as
appropriate for your shell.

The man pages will then be displayed with vim called as "view" and will use
the <man.vim> syntax highlighting.  I myself use some additional highlighting
which is enabled by putting the following file into <.vim/after/syntax/man.vim>.
I usually use the <astronaut> colorscheme (also available from this archive);
those who use bright backgrounds may find the colors selected for
manSubSectionStart and manSubSection something they'll want to change:

  ---------------------------------------------------------------------
" DrChip's additional <man.vim> stuff

syn match  manSectionHeading    "^\s\+[0-9]\+\.[0-9.]*\s\+[A-Z].*$"
contains=manSectionNumber
syn match  manSectionNumber     "^\s\+[0-9]\+\.[0-9]*"              contained
syn region manDQString          start='[^a-zA-Z"]"[^", )]'lc=1      end='"'
contains=manSQString
syn region manSQString          start="[ \t]'[^', )]"lc=1           end="'"
syn region manSQString          start="^'[^', )]"lc=1               end="'"
syn region manBQString          start="[^a-zA-Z`]`[^`, )]"lc=1      end="[`']"
syn region manBQSQString        start="``[^),']"                    end="''"
syn match  manBulletZone        transparent "^\s\+o\s" contains=manBullet
syn case    match
syn keyword manBullet contained o
syn match   manBullet contained "\[+*]"
syn match   manSubSectionStart  "^\*"   skipwhite nextgroup=manSubSection
syn match   manSubSection       ".*$"   contained

hi link manSectionNumber    Number
hi link manDQString         String
hi link manSQString         String
hi link manBQString         String
hi link manBQSQString       String
hi link manBullet           Special
hi manSubSectionStart       term=NONE cterm=NONE gui=NONE ctermfg=black
ctermbg=black guifg=navyblue guibg=navyblue
hi manSubSection            term=underline cterm=underline gui=underline
ctermfg=green guifg=green
set ts=8
  ---------------------------------------------------------------------
 
%
GVIM has an excellent syntax highlighting for XPM images, but sometimes it's
useful to view the actual data. This can be achieved by searching for
everything, type in "/." and all characters will be highlighted and therefore
the old colouring is lost. To regain the normal highlighting you can search for
a non-existent sequence, like "/foo".
%
     An FAQ on the vim users' mailing list is whether <Tab> and <C-I>
can be mapped to different things.  The answer is no.  As I understand
it, this is a low level issue:  <Tab> and <C-I> are different names
for the same ASCII code, and there is no way for vim to tell them
apart.  Similarly, <Esc> and <C-[> are the same thing.
%
Imagine.

You have just finished a complicated modification of a file, 
involving numerous replace commands :%s/xxx/yyyy/g, 
and other ex commands.

Then you realize, you have done it a little bit wrong, 
and you have to begin all the operation again, 
just to change one replace string, or do one more operation
"somewhere 10 commands ago".

Or you realize, you will have to do the same stuff tomorrow 
with another file.

or you realize, you want to perform the same sequence
of commands, you have typed a few days ago

You should have made it a macro (normal command q), 
but you haven't.

Nothing is lost yet.

You go to the command line (by typing :)
and press Ctrl+F.
(Ctrl+F in other modes scrolls the screen)

You get a temporary window, listing the history of command line.
It is possible to yank appropriate lines here,
make a new file called $VIMRUNTIME/macros/something.vim
put those lines here, edit them and save

see
:help cedit


Then you can call the macro using 
:source something.vim


You might want to set variable 'history' to a higher
number then default in your vimrc file
like
:set history=300
see
:help history
:help vimrc
%
VimTip 171: Do you know the "g/" and "g?" commands?
http://vim.sf.net/tips/tip.php?tip_id=171

Directly from the Vim Todo list:

7   For Visual mode: Command to do a search for the string in the marked area.
    Only when less than two lines. Use "g/" and "g?".


In other words, a way to search for visually selected text !!  :-)

"==== vsearch.vim ====

" Visual mode search

vmap g/ :call VsearchPatternSave()<cr>/<c-r>/<cr>
vmap g? :call VsearchPatternSave()<cr>?<c-r>/<cr>

function! VsearchPatternSave()
  let l:temp = @@
  normal gvy
  let @/ = substitute(escape(@@, '/\'), "\n", "\\\\n", "g")
  let @@ = l:temp
  unlet l:temp
endfunction

"==== END ====


Normally, this file should reside in the plugins directory and be automatically
sourced. If not, you must manually source this file using ':source vsearch.vim'.

In Visual mode, highlight the text for searching.  Then you can use the
default visual key mappings

g/ - search forwards
g? - search backwards

Visual searches behave like normal searches.  The 'n' and 'N' commands
work as they should, and the search history correctly records each search.
Multi-line searches behave as they should (this corrects the 'yank-only'
method mentioned in the Vim help files).  Block visual searches do not work
yet.  Hopefully, someone can figure out a way to do this easily.

I've only tested this on Win2000 and Redhat Linux 7.1.  I'm not really clear
on how the carriage returns are dealt with on other systems.

Anyway, enjoy!
%
Suppose you would like to use Ispell to check a word or region that you've
visually highlighted.  The following macro will do the job.  Just type
Shift-Insert while in visual mode.

vnoremap <S-Insert> <C-C>`<v`>s<Space><Esc>mq:e
ispell.tmp<CR>i<C-R>"<Esc>:w<CR>:! xterm -bg ivory -fn 10x20 -e ispell
 %<CR><CR>:e %<CR><CR>ggVG<Esc>`<v`>s<Esc>:bwipeout!<CR>:!rm
ispell.tmp*<CR>`q"_s<C-R>"<Esc>

This is based on Chip Campbell's macro which uses Ispell on the whole file
(in normal mode).

noremap <S-Insert> :w<CR>:! xterm -bg ivory -fn 10x20 -e ispell %<CR><Space>:e
 %<CR><Space>

Carl Mueller
%
I am a Web developer and I use Vim as my primary editor. 

Most programming projects (and Web programming projects, in particular) are
spread out over multiple files, which you often want to have open concurrently.
If you don't already know, Vim supports this very well! Just use:

:sp name-of-another-file-to-edit

My problems were that (1) it took too long to move between files, and (2) the
files were taking up too much room on the screen. 

(1) In order to move to the file in the split above my current window, I was
typing Ctrl-W, Up (move up a window) Ctrl-W, _ (maximize the menu). That's four
keystrokes (more if you count Ctrl and Shift), and they are all over the
keyboard. To help avoid this problem, I created this mapping in my .vimrc:

map <C-J> <C-W>j<C-W>_
map <C-K> <C-W>k<C-W>_

Now I can hold down Ctrl and move between windows with the standard Vim
movement keys. Much, much quicker!

(2) By default, Vim displays the current line of each minimized file, which (to
me) isn't much help and takes up too much screen real estate. I use this line
in my .vimrc:

set wmh=0

This sets the minimum window height to 0, so you can stack many more files
before things get crowded. Vim will only display the filename. 

Hope this helps those of you who are working on projects with large numbers of
files you're constantly flipping through. Happy Vimming! 
%
ab (1 [1]<esc>:/^--\s/-1/<cr>o<insert><cr>Footnotes:<cr>----------<cr>[1]
ab (2 [2]<esc>:/^Footnotes\:/+2/<cr>o<insert>[2]
ab (3 [3]<esc>:/^Footnotes\:/+3/<cr>o<insert>[3]
ab (4 [4]<esc>:/^Footnotes\:/+4/<cr>o<insert>[4]
ab (5 [5]<esc>:/^Footnotes\:/+5/<cr>o<insert>[5]
%
hi,
if u have installed vim in your home directory somewhere
and u don't have a root account, and you want to
make VIM the default editor for anything u do.
i.e if ur using SQLplus and want to edit a sql command.
normally typing edit brings up the vi editor and not vim editor.
to solve this problem.
define these three variables in your .profile
VIM=<base directory where vim executable is placed>
VIMRUNTIME=<base direcoty where vim runtimes are kept>
EDITOR=$VIM/vim 

note if u have installed vim with another name, say vim.exe then
change EDITOR=$VIM/vim to EDITOR=$VIM/vim.exe

source the .profile and viola. next time u start an editor from any
program u have the vim editor.

Njoy.
%
The following code automatically checks out files from perforce when the user
modifies them. It first confirms the check-out with the user.

(Perforce is a commercial version control system.  I imagine this could be
modified for RCS, CVS, etc., but I don't use those.)

I'm a vim newbie -- I've used vi since 1984, but just started with vim a couple
days ago.  Color me impressed!  Please excuse any stupidity in the code..

Note that this function needs the "P4HOME" environment variable to be set.  I
could extract it by invoking "p4 client", but I don't want to invoke p4 every
time I start vim.  So I assume the user sets it in the environment.

" Set a buffer-local variable to the perforce path, if this file is under the
perforce root.
function IsUnderPerforce()
    if exists("$P4HOME")
        if expand("%:p") =~ ("^" . $P4HOME)
            let b:p4path = substitute(expand("%:p"), $P4HOME, "//depot", "")
        endif
    endif
endfunction
" Confirm with the user, then checkout a file from perforce.
function P4Checkout()
   if exists("b:p4path")
        if (confirm("Checkout from Perforce?", "&Yes\n&No", 1) == 1)
            call system("p4 edit " . b:p4path . " > /dev/null")
            if v:shell_error == 0
                set noreadonly
            endif
        endif
    endif
endfunction

if !exists("au_p4_cmd")
    let au_p4_cmd=1

    au BufEnter * call IsUnderPerforce()
    au FileChangedRO * call P4Checkout()
endif
%
Check out http://www.erols.com/astronaut/vim/index.html#VimFuncs for
a plugin script which highlights matching brackets.  The script has
two always-on maps:
	\[i   : start [HiMtchBrkt] mode
	\[s   : stop [HiMtchBrkt] mode
The plugin will save all user maps and options that the plugin uses and
will restore them when the mode is stopped.
%
Suppose there's a colorscheme that you're pretty fond of, but hate one or two
particular aspects about.  For example, I love the "blue" colorscheme that
ships with vim, but I find it's colors for the non-active status line to be
unreadable.  Here's how to create a colorscheme which extends "blue" without
copying it to a new file and editing it.

In my ~/.vim/colors, I created a "my-blue.vim" file with these contents:

"these lines are suggested to be at the top of every colorscheme
hi clear
if exists("syntax_on")
   syntax reset
endif

"Load the 'base' colorscheme - the one you want to alter
runtime colors/blue.vim

"Override the name of the base colorscheme with the name of this custom one
let g:colors_name = "my-blue"

"Clear the colors for any items that you don't like
hi clear StatusLine 
hi clear StatusLineNC

"Set up your new & improved colors
hi StatusLine guifg=black guibg=white
hi StatusLineNC guifg=LightCyan guibg=blue gui=bold

That's all there is to it.
%
Vim is distributed with comprehensive help system, which has basic hyperlink
support - 
you can press <C-]> over |some subject| or 'some option' to read more about
particular term.

The following mappings simplify help buffer navigation:
pressing s(or S) will find next(previous) subject from cursor position
pressing o(or O) will find next(previous) option from cursor position
pressing Enter will jump to subject under cursor
pressing Backspace will return from the last jump

Put them into help filetype plugin (like ~/.vim/ftplugin/help.vim on UNIX).

nmap <buffer> <CR> <C-]>
nmap <buffer> <BS> <C-T>
nmap <buffer> o /'[a-z]\{2,\}'<CR>
nmap <buffer> O ?'[a-z]\{2,\}'<CR>
nmap <buffer> s /\|\S\+\|<CR>
nmap <buffer> S ?\|\S\+\|<CR>
%
Ever tried to write/debug your own  filetype/syntax plugin?

It's an iterative process which involves editing plugin code and testing it on some
sample file. To see changes you made in your plugin simply do :e on sample file.
This will force Vim to reload all buffer-specific files, including your plugin.
%
Hi,
there has been a number of person (including) asking in the vim list how to
keep up with Bram's incredible bug correction 
and patch writing skills, but there is a great way to do this!
Use the cvs source which is available at http://sourceforge.net/cvs/?group_id=8
it is kept up to date and its a lot easier than applying all the patch in order.
Benoit
%
i hope i don't hear a collective 'DUH!' from around the world but i just did
this and i think it's kinda cool.

in your .vimrc add...

map j jzz
map k kzz

so whenever you go up or down, vim does that and then re-centers.
obviously it doesn't work when you page up/ down.
%
The :bu command will take a pattern as an argument and jump to the matching
buffer.  However, it's not very helpful if there is more than one buffer
matching the pattern.  In that case, it will jump to the first match, which may
not be what you want.  The following function and user-command will print a
list of the matching buffers in the command-line area, and allow you to select
one of the matching buffers by number.

"Select from buffers matching a certain pattern
"the 'pattern' argument shouldn't be prepended with a slash

function! BufSel(pattern)
   let bufcount = bufnr("$")
   let currbufnr = 1
   while currbufnr <= bufcount
      if(bufexists(currbufnr))
         let currbufname = bufname(currbufnr)
         if(match(currbufname, a:pattern) > -1)
               echo currbufnr . ":      ". bufname(currbufnr)
         endif
      endif
      let currbufnr = currbufnr + 1
   endwhile
   let desiredbufnr = input("Enter buffer number: ")
   if(strlen(desiredbufnr) != 0)
      exe ":bu ". desiredbufnr
   endif
endfunction

"Bind the BufSel() function to a user-command
command! -nargs=1 Bs :call BufSel("<args>")
%
Hi,
Lets say your writing some imp. doc. and your colleague
comes along. you don't wan't him to see what you are typing.
so u start fumbling to type :wq! or switch with Alt-TAB. etc.
but wouldn't it be nice to just obsucre the text temporarily,
so that u don't have to quit or swith to another application using Alt-tab.
(and if u don;t have any other window open u can;t even use alt-tab)
well rot-13 comes to help. vim has a built in rot-13 encoder.

jut put the follwoing in your .vimrc

map <F3> ggVGg?

so next time some body comes along just press <F3> and all the buffer will 
be rot-13 encoded. to decode just press <f3> again.
Njoy
%
Normally in Windows, if you try to "launch" a file whose extension is not
registered with the system, the OS will prompt you for what editor you would
like to use to open the file.  A much more appealing solution, in my mind, is
to make vim the default editor for any unregistered extension.  

To set vim up as the default editor for unregistered extensions, follow these steps:
1. Copy the following into a file named unregistered.reg
-------------begin unregistered.reg-----------------
REGEDIT4
[HKEY_CLASSES_ROOT\Unknown\shell\Open\Command]
@="d:\\program files\\vim\\vim60\\gvim.exe \"%1\""
-------------end unregistered.reg-----------------

2. Import unregistered into your registry.  This can be done in vim by
executing the following
:!regedit "unregistered.reg"

Disclaimer: This has been tested only on NT4.
%
My tip is just a bunch of mappings that can be used while searching.
What it does?
  o. Extend your current search. (kinda emacs search where you can search each
  occurences 
      one by one and go back to the cursor position.
  o. Scroll/position during mapping.
  o. Other miscellaneous stuffs ;) read on

How to use?
   o. copy and paste the mappings into a file
   o. open vim (like vim .profile)
   o. :so <saved-file>
   o. start using the mappings

Note:
   In case these mappings dont work run like, 'vim -u NONE -U NONE -c "so
   the-saved-file.vim"'

   Some of my mappings override the default vim bindings. (like Ctrl-A, Ctrl-Q). I
   selected those because, I feel by taking those I can do all the search stuff with
   my left hand.

   One thing I did not like with this is, I usually miss the "search hit
   bottom" message. I could have
   handled that by complicating the current mappings, but I preferred to make
   it simple

Mappings Used
/          => regular forward search start
?         => regular backward search start
Rest of the mappings are used during search
Ctrl-A  => search again forward (In normal mode, search forward with the word
under cursor)
Ctrl-Q  => search again backward (in normal mode, search backward with the word
under cursor)
Ctrl-X  => restore cursor (use at any point of time/during-any-operation
mentioned during searching)
Ctrl-F  => search with the word under cursor
Ctrl-G  => incrementally add the letters following the search pattern (in
current line)
Ctrl-T Ctrl-T => search for the exact
Ctrl-T Ctrl-Y => search partial (just strips \< and \>)
Ctrl-E  => scroll up during searching
Ctrl-Y  => scroll down during searching
Ctrl-Z Ctrl-Z => position the cursor to mid of screen (like zz in normal)
Ctrl-Z Ctrl-A => position the cursor to top of screen (like zt in normal)
Ctrl-Z Ctrl-X => position the cursor to bottom of screen (like zb in normal)

Misc:
Ctrl-K during search save the current matching line
Ctrl-K in normal mode pastes the saved line

C mappings
Ctrl-V Ctrl-G search for the global variable of the search pattern/word under cursor
Ctrl-V Ctrl-H search for the local variable of the search pattern/word under cursor

" --- cut n paste from here to end of document ---
se nocp incsearch
" core mappings
noremap  / mg/
noremap  ? mg?
ounmap /
ounmap ?
noremap <C-A> mg"gyiw/<C-R>g
cnoremap <C-A> <CR>/<Up>
cnoremap <C-X> <CR>`g
cnoremap <C-Q> <CR>?<Up>

" extending current search mappings
cnoremap <C-F> <CR>yiw<BS>/<C-R>"
cnoremap <C-G> <CR>y/<Up>/e+1<CR><BS>/<C-R>=escape(@",'.*\/?')<CR>

" miscellaneous: copy current line during search and later paste in NORMAL mode
cnoremap <C-K> <CR>"hyy?<Up><CR>/<Up>
noremap <C-K> "hp

" exact/partial search mappings
cnoremap <C-T><C-T> <Home>\<<C-End>\>
cnoremap <C-T><C-Y> <Home><Del><Del><End><Del><Del>

" C global/local variable search mappings
noremap <C-V><C-G> mgyiw<CR>gg/\<<C-R>"\>
noremap <C-V><C-H> mgyiw?^{<CR>/\<<C-R>"\>
cnoremap <C-V><C-G> <CR>yiwgg/\<<C-R>"\>
cnoremap <C-V><C-H> <CR>yiw?^{<CR>/\<<C-R>"\>

" positioning/scrolling during search mappings
cnoremap <C-E> <CR>mt<C-E>`t<BS>/<Up>
cnoremap <C-Y> <CR><C-Y><BS>/<Up>
cnoremap <C-Z><C-A> <CR>zt<BS>/<Up>
cnoremap <C-Z><C-X> <CR>zb<BS>/<Up>
cnoremap <C-Z><C-Z> <CR>zz<BS>/<Up>

" VISUAL mappings
vnoremap / ymg/<C-R>=escape(@",'.*\/?')<CR>
vnoremap ? ymg?<C-R>=escape(@",'.*\/?')<CR>
%
Did you know that with VIM u can search for more
than one word with a single command. 
say you want to search all occurances of "bill" or "ted", or
"harry" in a text.
in normal mode do the following.
/\(bill\)\|\(ted\)\|\(harry\) <Enter>

this will match all instances of either "bill", or "ted", or "harry" in your
text. the key is the \(\) and \| operators.
\(\) group characters in a word and \| is for ORing.

this is so cool u can even use it for replacing text.
to replace all instances of "bill" or "ted" or "harry" with "greg"
do the following
:%s/\(bill\)\|\(ted\)\|\(harry\)/greg/g <enter>
(note :- if u have set the option "gdefault" u don't need the "g" at the
end of the above command)

I don't know of any other editor which can do this, with so much ease.
Rock on VIM
Njoy
%
Stuff this into your ~/.gvimrc and then you'll be able to type
Control-Backspace to delete the previous word.  I had gotten so used to C-BS
working a certain way in all my editors with a ceezy input area (like
mozilla/galeon, gabber, etc...), that I wanted the same behaviour when I used
gvim.

" map control-backspace to delete the previous word
:imap <C-BS>        <Esc>vBc

Simple, I know, but reasonably useful.

--Robert
%
The issue is permitting other programs, besides NOTEPAD,
be the HTML editor under Internet Explorer. 
(Adding "Edit" as a New Action in the publicly exposed
Files Types for HTM/L does NOT do the job.)

Given below are two REG files for vim. 
Just cut 'em up where indicated.
They have been tested under Windows XP.


-------------------------------------------------------CUT HERE---------------
Windows Registry Editor Version 5.00

; GOAL: Set gvim as HTML editor in Internet Explorer 6.0
; Vim version : 6.0
; Windows version: XP 
; EASY USAGE: name this file iex-vim60.reg and double click on it
; Hard Usage: IMPORT this file using REGEDIT.EXE found in c:\WINDOWS 
; Last modified date : Dec 16, 2001

; gvim is expected in "C:\Program Files\Vim\vim60\gvim.exe"
; Be sure to also reset Explorer>Tools>Internet Options>Programs

; Microsoft documentation
;
http://msdn.microsoft.com/workshop/browser/configuration/clientreg/clientregistrylayout.asp

; Add Vim in the list of supported HTML editors
[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim]

[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim\shell]

[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim\shell\edit]

[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim\shell\edit\command]
@="\"C:\\Program Files\\Vim\\vim60\\gvim.exe\" \"%1\""

; Do NOT add to .html, registry for .htm type suffices
;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim]

;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim\shell]

;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim\shell\edit]

;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim\shell\edit\command]
;@="\"C:\\Program Files\\Vim\\vim60\\gvim.exe\" \"%1\""


; OPTIONAL: Within Internet Explorer "View Source" with gvim
; but prefer to use Edit button (got to add this) on Toolbar
;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source Editor]

;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source
Editor\Editor Name]
;@="C:\\Program Files\\Vim\\vim60\\gvim.exe"

; ============================================= EOF

-------------------------------------------------------CUT HERE---------------
Windows Registry Editor Version 5.00

; GOAL: UNINSTALL gvim as HTML editor in Internet Explorer 6.0
; Vim version : 6.0
; Windows version: XP 
; EASY USAGE: name this file iex-vim60-uninstall.reg and double click on it
; Hard Usage: IMPORT this file using REGEDIT.EXE found in c:\WINDOWS 
; Last modified date : Dec 16, 2001

; gvim is expected in "C:\Program Files\Vim\vim60\gvim.exe"
; Be sure to also reset Explorer>Tools>Internet Options>Programs

; Microsoft documentation
;
http://msdn.microsoft.com/workshop/browser/configuration/clientreg/clientregistrylayout.asp


[-HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim]

[-HKEY_CLASSES_ROOT\.html\OpenWithList\Vim]

[-HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source Editor]


; ============================================= EOF
-------------------------------------------------------CUT HERE---------------

Happy Vimming...
%
You can easily move lines with these maps using <C-Up> and <C-Down> (only in
GUI version :( )
(Works in normal, insert, and visual mode, but you can't add a count to them)
" Transposing lines
nmap <C-Down> :<C-u>move .+1<CR>
nmap <C-Up> :<C-u>move .-2<CR>

imap <C-Down> <C-o>:<C-u>move .+1<CR>
imap <C-Up> <C-o>:<C-u>move .-2<CR>

vmap <C-Down> :move '>+1<CR>gv
vmap <C-Up> :move '<-2<CR>gv

" Transpose chars (like Ctrl-T in emacs, shell...)
imap <C-F> <Esc>Xpa
%
LaTeX Help for aucTeX `translated' as vim help file.

Installing

:help add-local-help
%
I found this one good for when I was starting to learn Java, it simply inserts
the current filename, at the cursor position, when you are in insert mode.
Honestly, its a mish-mash of some other tips I found here, but I thought it
might be useful.

imap \fn   <C-R>=expand("%:t:r")<CR>

Enjoy!
%
Do you know the I key in visual-block mode?

Suppose you have
let a=2
let b=3
let c=4

You want to make these variables script-wise. Then you move to over a, hit
<C-v>, press jj and now press I.
You will be in insert mode before a
Now enter s:<Esc>, and when you press <Esc>, b and c will have the s: prefix too.
See |v_b_I|

Happy vimming!
Gergely Kontra
%
When you edit multiple files, you often need to change windows.
You can set up vim in windows and gvim to switch between windows with the
commonly used Ctrl-Tab and Ctrl-Shift-Tab
The mappings
nmap <C-Tab> <C-w>w
nmap <C-S-Tab><C-w>W
(They wrap around)
See also |Ctrl-w|
%
In shell scripts, you often define environment variables for diff directory names.
i.e.
JAVA_HOME=/opt/java/jdk1.4
PATH=/usr/local/bin:/bin....

Normally typing Ctrl-X Ctrl-F is used to complete FileName under cursor.
But this does not work if used on lines given above.
This is because vim treats "=" sign as a valid filename character.
Since the actual possibility of "=" being in any filename is very less, this
char can be removed from the list of valid filename char.

set isfname-==

putting the above line in .vimrc will remove "=" from the list of valid
filename chars.
thus u can easyly complete filenames using <Ctrl-X> <Ctrl-F>
Njoy
%
If you want edit new file, and you  want do it  in alrady running vim, instead
of launching another instance, you may use --remote argument:

gvim first_file
gvim --remote +split first_file

:he --remote
It requires X windows (but works in terminal version of vim there too) or MS
windows and built-in client-server mechanism. If there are several instances of
vim already running, you may choose to which you talk using --servername
:help --servername
%
When sending code snippets or diffs to your colleagues either for code review
or for something else as email, how nice and clear it will be if you can paste
it with the Vim syntax highlighting? I am sure they will be impressed and feel
much easier to read the code. It is also very easy and fast (once you practice
it) to do this.

This probably works only on windows and requires you to use Internet Explorer
and an email client that understand RTF content coming from clipboard, such as
Outlook or Outlook Express. At least that would make the process faster. I
haven't tried on any other combination though. This is what you need to do:

- Open the file containing the code/code snippet/diff etc. in gvim. If you use
  dark background for GVim (like me), then I would suggest you to change your
  color scheme temporarily to something else that has a white background or
  just use the "-U NONE" as below:

    gvim -U NONE <file>

- Convert the file into HTML by using the following command at the colon prompt
  as below:

    :runtime syntax/2html.vim

- The above step will open a new window with the HTML content in it. You might
  want to just save it with the suggested name or write into a temporary file
  as:

    :w! c:/tmp/t.html

- Open the IE browser window and open the above temp file "c:/tmp/t.html".
- Now you select all (press ^A) and copy it (^C).
- You are ready to paste it with syntax coloring in any application that
  accepts RTF content from clipboard, including Outlook or Outlook Express mail
  composing window.
%
Say you have layed out a complex window split structure, and want to
temporarily open 1 window with max dimensions, but don't want to lose your
split structure.  The following function and mappings let you toggle between
the split windows and on window maximized. The mappings prevent the default
behavior of calling :only and losing your finely tuned splits.

Put this bit in your vimrc file, change mappings if you don't want to override
the defaults:

nnoremap <C-W>O :call MaximizeToggle ()<CR>
nnoremap <C-W>o :call MaximizeToggle ()<CR>
nnoremap <C-W><C-O> :call MaximizeToggle ()<CR>

function! MaximizeToggle()
        if exists("s:maximize_session")
                source s:maximize_session
                call delete(s:maximize_session)
                unlet s:maximize_session
                let &hidden=s:maximize_hidden_save
                unlet s:maximize_hidden_save
        else
            	let s:maximize_hidden_save = &hidden
                let s:maximize_session = tempname()
                set hidden
                mksession! s:maximize_session
                only
        endif
endfunction
%
When one is inserting parentheses some folks like to see the cursor
bounce off the matching parenthesis.  To do that, put the following
map into your <.vimrc> file:

    inoremap ) )<c-o>%<c-o>:sleep 500m<CR><c-o>%<c-o>a

Adjust the time delay (its 500 milliseconds above) to suit your needs.
%
Use this tip if you need to discover the meaning of life, the universe and
everything.

Simply do:
:h 42
%
Don't know how people debug autocommands, but I just found out that you can
debug (at least) those that result due to window close by just doing a debug
quit, i.e.,

:debug quit

Vim will let you step into the autocommands. Try it to believe.
%
I find this a very useful command to use.
Add the below 4 lines to your vimrc.
Then instead of "make" use "Make".

" Command Make will call make and then cwindow which
" opens a 3 line error window if any errors are found.
" if no errors, it closes any open cwindow.
:command -nargs=* Make make <args> | cwindow 3
%
These mappings can make using cscope a fun. You can copy the word under the
cursor in one window, and search for it from other window.

" Copy and paste the word under cursor
map <silent> <C-Space> :let@m=expand("<cword>")<CR>

" Use the C-Space word as the search criterion
map <C-F6> :cscope find s <C-R>=@m<CR><CR>
map <C-F5> :cscope find c <C-R>=@m<CR><CR>
map <C-F7> :cscope find g <C-R>=@m<CR><CR>
%
"Sometimes you need to sum a some numbers in vim.  There *are* some plugins
"that can do the job.  But what if the numbers are not in a columns or are on
"the same line or are sacttered all across the file? You might also need to
"sum all the numbers in file that look like '1234$', or '54565 Eu'  ignoring others.
"
"There is a very simple trick, using (my favourite) command 
":s
"
"First you define following function

:let g:S=0 		"In global variable S we later find the result

:function! Sum(number)		"The function is defined with a '!',
				"so it does not complain during debugging
				"when you are redefining the function
	:let g:S=g:S+a:number	"we accumulate the result in global variable S
	:return a:number	"function returns the argument, so after a :s
				"command the text remains the same
:endfunction

"you can do issue those few commands from a command line, 
"or create a small file and put it into your plugin directory,
"or write those few commands into a file end issue a command :so %



"how to use this little function:
"let's suppose you have a simple column of numbers like
"
"10
"20
"30
"
"you issue command like:
:let S=0
:%s/[0-9]\+/\=Sum(submatch(0))/
"the command finds the first number on the line and adds it to the S
"
"the result is displayed 
:echo $S

"!!!! don't forget to do
:let g:S=0 
"before use.

"you can also use \zs and \ze atoms in a regular expression to 
"delimit the number, so submatch(0) returns only a number and 
"the text remains unchanged after 'substitute'


"for starter on the wonderfull world of regular expressions see:
:help usr_27.txt

"for the definition of the search pattern see 
:help :s
:help pattern

"for replacement strings begining with \= and special function submatch(0)see 
:help sub-replace-special

"for the *ultimate* guide through the world of regular expressions see book:
"Mastering Regular Expressions
"Powerful Techniques for Perl and Other Tools
"by Jeffrey E.F. Friedl
"from O'REILLY

"the book does not write about vim, yet here you can learn that
":s command is the most powerfull command you can find in a text editor. 
"(with the possible exception of :global command)
%
An error I sometimes make while working on a LaTeX file is the repetition of a
word as in "the the". Most often, such doubled words come about through a
careless edit. Doubled words are hard to spot when the first word of the
doubled pair is the last word on one line, and the second word of the pair is the
the first word on the next line. There is an example of such an error in the last 
sentence. Vim's syntax mechanism can be used to highlight doubled words as an error.

To obtain this highlighting for TeX and LaTeX files, place the following two lines:

       syn match texDoubleWord "\c\<\(\a\+\)\_s\+\1\>"
       hi def link texDoubleWord Error

in a file called tex.vim in the directory that shows up last in your
runtimepath (:set runtimepath? to check). This will often be 
either ~/.vim/after/syntax/tex.vim or $VIM/vimfiles/after/syntax/tex.vim 

The same effect can be obtained for files of a different filetype, say html,
by putting the same lines in a file called html.vim in the same location.

For more on the runtimepath, :he runtimepath.
For more on syntax highlighting, :he syntax
%
Perl's Data-Base-Independent (DBI) module provides programming language level
access to a lot of databases.

Vim hosts an embedded Perl interpreter. So it is only a matter of some key
strokes to interactively issue DB commands from within Vim or to search, edit,
and replace database contents including retrieval and storage. Of course
"create table" scripts can be worked upon in Vim as well as storing recurring
patterns in Vim functions or Perl modules.


Prerequisites: Vim needs to be compiled with Perl support enabled. See the
|if_perl.txt| manual page! The CPAN module DBI as well as an appropriate
database driver has to be installed with Perl in order to execute these Vim
commands:

" connect to perl's dbi module:
:perl use dbi;

" connect to the database:
:perl $dbh = dbi->connect( "DBI:mysql:$DBNAME:$HOST",$USER,$PASSWORD,
                                        { raiseerror => 1});

" perform a simple query:
:perl $result = $dbh->selectall_arrayref("show tables;");

" insert the list of tables into the current buffer's top:
:perl $curbuf->Append(0, map($_->[0], @{$result}));

In MySql the command "show tables;" results in a list of table names. Inserted
into a Vim buffer this results in one line per table.


You can find more on my web page
http://members.chello.at/intelliware/dbEdit
%
If you use the buffers menu, here's where you can change how the buffernames
are displayed:

menu.vim, function s:BMMunge

OLD:   let name2 = name2 . ' (' . a:bnum . ')'

displays:
  
  .vimrc (1)
  menu.vim (2)


NEW:    let name2 = '&' . a:bnum . '. ' . name2 

displays
  
  1. .vimrc 
  2. menu.vim
(with the 1 and the 2 underlined)

which is more useful, because you can (almost) always pick the buffer you want
with one keystroke, the buffernumber, until you get to buffer 10 anyway.

Roger
%
If you are jumping from one line to another a lot.
You may find the "Ctrl-o" command handy.
Usually u can set markers in a buffer to keep track of your
movements.
but Ctrl-o makes it even easier. it takes you back sequentially to
all your previous cursor locations in a buffer.
just press ctrl-o in normal mode and u will go to your last cursor position.

Njoy
%
if you use  set makeprg=gcc\ -o\ %<\ % in your .vimrc, and your actual file is
file.c,  then :make will compile file.c with the output file. (gcc file.c -o
file).
%
This tip is for those who like to change their vim color themes pretty often.
I like different themes just for a change in my work environment.  To achieve
this just add the following to your .vimrc or _vimrc file.

let themeindex=0
function! RotateColorTheme()
	let y = -1	
	while y == -1 
		let colorstring =
		"#blue.vim#elflord.vim#evening.vim#koehler.vim#murphy.vim#pablo.vim#ron.vim#"
		let x = match(colorstring,"#",g:themeindex)
		let y = match(colorstring,"#",x+1)
		let g:themeindex = x+1
		":echo x y g:themeindex
		if y == -1
			let g:themeindex = 0
		else
			let themestring = strpart(colorstring,x+1,y-x-1)
			echo("Setting Theme to-> ".themestring)
			return ":so $VIMRUNTIME/colors/".themestring
		endif
	endwhile
endfunction

Change the value of colorstring above by changing the line
let colorstring =
"#blue.vim#elflord.vim#evening.vim#koehler.vim#murphy.vim#pablo.vim#ron.vim#"
You can add your favorite color themes in this string so that you can rotate
between them.  Just make sure that any string that you add is in between the #
as shown above.  Just follow the format above and things will work.

Then assign a key to roate the theme.  
map <F8> :execute RotateColorTheme()

Dunno if there are better ways to do the same.  I just did a "help eval" and
wrote the above.  
%
While creating scripts and others executable files with Vim it is needed to set
UNIX executable bit on the file.
You can do this from inside Vim with :!chmod a+x %. The % represents current
buffer's filename.
The problem is that Vim will notice attribute changes and prompt you to reload
a file. If you do this, your undo history for the file will be lost.

The following function facilitate changing executable attributes without
reloading a buffer.
Thanks to Bram for the algorithm for this function.

fun! SetExecutableBit()
	let fname = expand("%:p")
	:checktime
	exec "au FileChangedShell " . fname . " :echo"
	:silent !chmod a+x %
	:checktime
	exec "au! FileChangedShell " . fname
endfun

" Create an EX command that will call the function.
command -nargs=0 Xbit call SetExecutableBit()

Now you can type :Xbit to make the file executable!
%
I needed this one when I was editing an ldif file:

I needed to delete all lines containing "profile":

:g/profile/d

very handydandy
%
If you have different menus for different filetypes, and you want to have only
the menu relevant to current buffer displayed, you can use this approach:

in .vimrc:
au BufEnter * if exists('b:BuffEnter')|exec b:BuffEnter|endif
au BufLeave * if exists('b:BuffEnter')|exec b:BuffLeave|endif

In appropriate ftplugin/?.vim, there are assigned commands to create or destroy
the menus - here typed in directly, may be of course call to a menu-generating
function or whatever.

let b:BuffEnter='amenu C.added ...'
let b:BuffLeave='unmenu! C|unmenu C'
%
When you open a file, vim may load several scripts to customize itself for
editing the file type the file is associated with (for example a file "test.c"
is associated with the filetype "c").
Such configurations include the setting of syntax highlighting colors (:help
syntax) and support for indentation (:help filetype-indent-on).
When you start to override these files for yourself, it can sometimes be
confusing, which file sets a specific option.
The following function can be used, to edit the configuration files which are
associated with a specific filename. It open a buffer for all files which get
loaded.
If I invoke it with ':call Edit_ft_conf("test.c")', for example, I end up with
the following buffers / windows:
  1  a   "[No File]"                    line 1
  2  a   "test.c"                       line 1
  3  a=  "/usr/local/share/vim/vim60/syntax/c.vim" line 1
  4  a   "~/.vim/after/syntax/c.vim"    line 1
  5 #a=  "/usr/local/share/vim/vim60/indent/c.vim" line 1
  6 %a=  "/usr/local/share/vim/vim60/ftplugin/c.vim" line 1


Here comes the function:

" Edit filetype configuration files
" Usage: ':call Edit_ft_conf("file")'
" Purpose: open all scripts which get loaded implicitly by opening "file"
"   (syntax highlighting, indentation, filetype plugins, ..)
"   The order of windows reflects the order of script loading (but "file" is
"   the topmost window)
fun! Edit_ft_conf(name)
    " we may not do this with a loaded file, since this won't trigger the
    " configuration file loading as desired.
    " try calling with 'call Edit_ft_conf("nonexistingfile.<EXT>")' if this
    " gives you troubles
    if bufexists(a:name) && bufloaded(a:name)
        echo "!Attention: buffer for " . a:name . " is loaded, unload first."
        return
    endif
    " split-open the file with verbose set, grab the output into a register
    " (without clobbering)
    let safereg = @u
    redir @u " redirect command output to register @u
    exec "silent 2verbose split " . a:name
        " verbose level 2 suffices to catch all scripts which get opened
    redir END
	" Parse register @u, looking for smth like:
	'sourcing"/usr/local/share/vim/vim60/syntax/c.vim"'
    let pos = 0
    let regexp = 'sourcing "[^"]\+"'
    while match(@u,regexp,pos) >= 0
        let file = matchstr(@u,regexp,pos)
        let pos = matchend (@u,regexp,pos)
        let file = strpart(file,10,strlen(file)-11)
        exec "silent below split " . file
    endwhile
    " restore the register
    let @u = safereg
endfun
%
The following map and function calculates equations using the program 'bc'
(found on most linux systems, available for most systems).  Visually select the
equation you want to calculate, then hit ;bc - if the selection ends with an
'=' sign, the answer will be appended after the equal, otherwise, the answer is
echoed as a message.  The code to put in a vimrc and source is at the end.

Equations can span multiple lines, and the full bc syntax is probably
supported.  Additionally, sin (), cos (), etc, are transformed into the names
used by bc (s () c (), etc).

Here are some example lines:

2 * sqrt (2) = 

3 * (2 - 1) + 4.0 ^ 6 = 

4 / 3 = 

3 + 
   4 -
      2 * (1 / (3 + 2)) = 

define rad (x) {
  return (x / 180) * 4 * atan (1)
}
cos (rad (45)) = 

Select each of these in turn (continguous non-blank lines, and hit ;bc for
each), and this is what you get:
2 * sqrt (2) = 2.82842712474619009760

3 * (2 - 1) + 4.0 ^ 6 = 4099.000000

4 / 3 = 1.33333333333333333333

3 + 
   4 -
      2 * (1 / (3 + 2)) = 6.60000000000000000000

define rad (x) {
  return (x / 180) * 4 * atan (1)
}
cos (rad (45)) = .70710678118654752440


Fun, no?  Here is the code you need to put in your vimrc file:

vnoremap ;bc "ey:call CalcBC()<CR>
function! CalcBC()
	let has_equal = 0

	" remove newlines and trailing spaces
	let @e = substitute (@e, "\n", "", "g")
	let @e = substitute (@e, '\s*$', "", "g")

	" if we end with an equal, strip, and remember for output
	if @e =~ "=$"
		let @e = substitute (@e, '=$', "", "")
		let has_equal = 1
	endif

	" sub common func names for bc equivalent
	let @e = substitute (@e, '\csin\s*(', "s (", "")
	let @e = substitute (@e, '\ccos\s*(', "c (", "")
	let @e = substitute (@e, '\catan\s*(', "a (", "")
	let @e = substitute (@e, "\cln\s*(", "l (", "")

	" escape chars for shell
	let @e = escape (@e, '*()')

	" run bc, strip newline
	let answer = substitute (system ("echo " . @e . " \| bc -l"), "\n", "", "")

	" append answer or echo
	if has_equal == 1
		normal `>
		exec "normal a" . answer
	else
		echo "answer = " . answer
	endif
endfunction
%
I found a website *cough*Tivoli.com*cough* that likes to obfuscate some of its
help file web pages using &#nnn; instead of normal ascii.  If you load the
source with Vim (in Opera you can just designate Vim as your source viewing
program), you can :so the following code to make it readable.

let n = 32
while n < 127
    if n == 38
        silent! exec '%s/&#38;/\&amp;/g'
    elseif n == 47
        silent! exec '%s/&#47;/\//g'
    else
        silent! exec '%s/&#' . n . ';/' . nr2char(n) . '/g'
    endif
    let n = n + 1
endwhile

Disclaimer: I hacked this together in about 10 minutes (or possibly longer :).
It worked suitably for the website I wrote it for (or possibly "against" :).
Your Milage May Vary.

See :help eval, :help silent, :help exec, :help :s
%
For some scripts it might be useful to detect, whether a specific position in a
buffer is inside
of a comment or not. Syntax highlighting can save us the work for parsing the
comments ourselves.

The command
  :echo synIDattr(synIDtrans(synID(line("."), col("."), 0)), "name")
echoes the group used for *highlighting* the character at the current cursor
position, see ':help synIDtrans()'. It will usually be "Comment" if the cursor
is inside of a comment, so
   synIDattr(synIDtrans(synID(line("."), col("."), 0)), "name") == "Comment"
detects, independent of the filetype (which have their own group 'names' for
comments), if the cursor is inside a comment or not.
The expression
  synIDattr(synIDtrans(synID(line("."), col("."), 0)), "name") =~
  'Comment\|Constant\|PreProc'
will detect additionally, if the cursor is inside of a string or some
preprocessor statement.
%
A simple alias (*csh) or shell function (bash) will let you run make from your
shell, then automatically open vim or gvim on the errors (if there were any):

csh or tcsh:

alias Make 'make \!* |& tee make.errors || gvim -q make.errors -c :copen'

bash:

Make () { command make "$@" |& tee make.errors || gvim -q make.errors -c :copen ; }

If you use vanilla sh or ksh or even cmd.exe, you can probably do the same -
add a not if you have ideas.
%
This is a regular expression that matches all words except 'foo'
\v<(foo>)@!\k+>

\v 		Very magic
<		Start-of-word
(Foo>)	The atom 'Foo' followed by end-of-word
@!		Match (with zero length) when the previous atom doesn't
match.
\k+		Match one or more Keywords
>		Match end-of-word.

This is a kool example of using \@! in the middle of a regexp.
The non-magic version is:
\<\(foo\>\)\@!\k\+\>
%
I want to indent java files like this:

    int x(int y, int z)
        throws Exception
    {
        [...]
        return something;
    }

By default vim will properly indent "throws" line, but following "{" will not
be deindented back to the method declaration.

The following indentexpr does the trick:
let &indentexpr='getline(v:lnum)=~"^\\s*{" &&
getline(v:lnum-1)=~"^\\s*throws\\s" ? cindent(v:lnum)-&sw : cindent(v:lnum)'

It just checks that the current line starts with "{" and the previous line
starts with "throws" and if that is the case, it subtracts one shiftwidth from
the number returned by cindent.
%
Following the normal steps of running "./configure" and "make" to build
vim on an HP-UX 10.20 will result in vim being linked with the termlib
library.  This library does not support certain termcap capability
codes, such as the "Co" code used to query the number of colors
supported by the terminal.  Consequently, vim will not display colors
when used with a color terminal such as a color xterm.

One solution to this is to run the configure script with the
"--with-tlib=curses" option, like this:

    ./configure --with-tlib=curses

This will cause vim to be linked with the HP-UX curses library, which
does support the color termcap capability codes.

Note that the xterm that comes standard with HP-UX 10.20 does not
display color character attributes.  To see colors when running vim in a
terminal window, you will also need to install a color terminal emulator
such as a recent xterm.
%
Suppose you want to reverse some text - I don't know why you would want to -
maybe you're dyslexic.  Anyway, I had a need, so this mapping will reverse
visually selected text.  Put the mapping in your vimrc or otherwise source it,
then visually select the word or words, and hit ;rv - really only works with
selections on one line:

vnoremap ;rv c<C-O>:set revins<cr><C-R>"<esc>:set norevins<cr>
%
VimTip 224: Shifting blocks visually
http://vim.sf.net/tips/tip.php?tip_id=224

I use the < and > commands on blocks a lot, and it has always annoyed me that
if you want to shift more than one 'shiftwidth', you have count how many
'shiftwidth's you want to enter the '[count]>', or restore the selection with
"gv". So I've cooked up two mappings that come in very handy:

:vnoremap < <gv
:vnoremap > >gv

These mappings will reselect the block after shifting, so you'll just have to
select a block, press < or > as many times as you like, and press <ESC> when
you're done to unselect the block.

I know it's not rocket science, but it sure has helped me a lot.
%
 vim can interact with the tricks that the latest xdvi does:

 * If one clicks at some place in xdvi, vim automatically jumps to the
   corresponding line in the LaTeX source file ("reverse search")
 * Also, from inside vim, one can jump to the corresponding line in xdvi
   which becomes highlighted ("forward search").

 Here is how to do it:

 * Reverse search:
   We start a vim server by:  vim --servername xdvi
   We start xdvi(k) on file.dvi by:
      xdvik -editor "vim --servername xdvi --remote +%l %f" file.dvi
   At the desired location in xdvi, we press:   <ctrl><left_mouse>
   Then, vim will jump to the corresponding line in the source file.

 * Forward search:
   Inside vim, we type, for example,  _g  which is the following mapping:
        (the following should be a single line)

   map _g  :execute "!xdvik -name xdvi -sourceposition " . line(".") .
   expand("%") . " " . expand("%:r") . ".dvi" <cr><cr>

    [the command to go to the point of xdvi that corresponds to line, eg, 77
     of the source file is (no space after 77)
       xdvik -name xdvi -sourceposition 77file.tex file.dvi  ]

  For the above to work one needs:
  1) A recent version of xdvi or xdvik (>22.39 I think)
  2) The package srcltx.sty and \usepackage{srcltx} (which should  be
     commented out when one finishes and is ready for printing etc).
  3) Our version of vim should have been compiled with +clientserver
     (however, my vim doesn't have it and still works, so try it before
      Bram finds out what is happening and fixes it)
%
I use the command 'gf' quite often. But with this command the current buffer is
hidden. To avoid that I use the following mapping :

map gw <Esc>:sp %<CR> gf

With this mapping the file under the cursor is opened after a horizontal split.
%
:g is something very old and which is very powerful. I just wanted to
illustrate the use of it 
with some examples. Hope, it will be useful for someone.

Brief explanation for ":g"
-------------------------
Syntax is:
    :[range]:g/<pattern>/[cmd]
You can think the working as, for the range (default whole file), execute
the colon command(ex) "cmd" for the lines matching <pattern>. Also, for all
lines that matched the pattern, "." is set to that particular line (for
certain commands if line is not specified "." (current line) is assumed).

Some examples
-------------
Display context (5 lines) for all occurences of a pattern
    :g/<pattern>/z#.5
    :g/<pattern>/z#.5|echo "=========="
    << same as first, but with some beautification >>
Delete all lines matching a pattern
    :g/<pattern>/d
Delete all blank lines (just an example for above)
    :g/^\s*$/d
Double space the file
    :g/^/pu =\"\n\"
    :g/^/pu _
    << the above one also works >>
Copy all lines matching a pattern to end of file
    :g/<pattern>/t$
Yank all lines matching a pattern to register 'a'
    0"ay0:g/<pattern>/y A
Increment the number items from current line to end-of-document by one
    :.,$g/^\d/exe "normal! \<c-a>"
Comment (C) lines containing "DEBUG" statements
    g/^\s*DEBUG/exe "norm! I/* \<Esc>A */\<Esc>"
A Reverse lookup for records
(eg: An address book, with Name on start-of-line and fields after a space)
    :g/<patern>?^\w?p               "if only name is interested
    :g/<patern>/ka|?^\w?p|'ap       "if name and the lookup-line is interested
    :g/<patern>/?^\w?|+,/^[^ ]/-1p  "if entire record is interested
Reverse a file (just to show the power of 'g')
    :g/^/m0

Foot note 1: use :v to negate the search pattern
Foot note 2: Some explanation of commonly used commands with :g
 :2,8co15 => Copy lines 2 through 8 after line 15
 :4,15t$  => Copy linesa 4 through 15 towards end of document (t == co)
    :-t$  => Copy previous line to end of document
     :m0  => Move current line to the top of the document
:.,+3m$-1 => Move current line through cur-line+3 to the last but one line
             of the document
Foot note 3: Commands used with :g are ex commands, so a help search should
             be,
                :help :<help-topic>
                eg. :help :k
%
I find the following setting useful when replying to email threads that have
lots of lines like the following:
> blah
> > blah
> > > blah

autocmd FileType mail map <F8> :%g/^> >/d<CR>

When replying to a mail and you want to remove everything except what the
person you are directly replying to wrote just press F8.
From the example above, you would just be left with
> blah

What it does is simply match any line starting with > > and deletes it.  It's
not perfect as sigs and other debris may remain but it takes a lot of the grunt
work out of replying to mails.
The autocmd only maps F8 when using mails, this is handy if you use F8 for
other things as I do.

:help autocmd
:help map
:help :g
%
I've seen several questions asked in the reflector which is available in the
help files. 
Yeah, I know the help is huge. But, you can try this command to show a list of
related
topics you are trying:
   :he <topic><c-d>
It is "some topic" followed by the key sequence Ctrl-D. For eg:
   :he xterm<c-d>
will show all the help topics matching xterm. Then you can do completion/copy-n-paste
the topic you are searching. Of course you can cycle through all the topics through 
repeated <TABS>, but if the number of hits are huge, it is cumbersome.

Enjoy vimming beginners!!!
-Arun
%
I work on jsp pages in my source tree but I have to copy the jsp files over to
the tomcat directory in order to view my changes.The following mapping will
copy the file being edited to another location.

command Cpage silent !cp '%:p' "c:/Progra~1/Tomcat/webapps/console/pages/%"

Explanation:

 % refers to the current buffer
 %:p refers to the path to the file 
silent suppresses the command prompt window.

Usage:

:Cpage
%
i frequently like to edit multiple files in the same vim session.  however, if
i come into vim from another window i frequently hit 'i' and start typing in
whatever buffer is currently being used -- this is often the wrong one
(requires <esc>, undo, go the other buffer and . to redo).

one way to work around this for me is to use a different color scheme depending
on what file i'm working on:

au BufEnter * if (exists("b:colors_name")) | let b:current_colors=colors_name |
execute "colorscheme " . b:colors_name | endif

au BufLeave * if (exists("b:current_colors")) | execute "colorscheme " .
b:current_colors | endif

if you define b:colors_name with a particular color scheme name, then the above
autocommands will switch to that colorscheme when you enter that window and
will return to the original color upon departure.

inside ftplugin/java.vim, for example, i might have b:colors_name set to
'morning', causing all java files to have a distinguishing color scheme.
%
 If you are using the Win32 version of Vim you can use this tip to search the
 Jdk help for the keyword under the cursor.
You need the winhlp32 version of the Jdk docs from this URL -
http://www.confluent.fr/javadoc/indexe.html.
It is a 16mb D/L and approx 85mb unzipped!

I added a command to the popup menu 
:amenu PopUp.JavaHelp	:!start winhlp32 -k <cword> F:\jdk\winhelp\JDK13.HLP <CR

And also made a keymapping
map J :!start winhlp32 -k <cword> F:\jdk\winhelp\JDK13.HLP <CR>

Trivial yes, but I find it quite useful.
%
For some tips on how to use Vim for writing Lisp code, see
http://www.lisp-p.org/i000/15-vim.
%
Hi VIMMERs

These tips save me wearing out my delicate little fingers with unnecessary
keystrokes.
They assume Unix, but I also use them on a Windows Unix Shell (MKS) as well

# When I know the file i want to edit is the most recent file in a directory

alias -x vew='vi `l\s -t * | head -1 `'

#When I know the file I want to edit contains a unique keyword
#this is actually in a little shell script call ed vg where the keyword is
passed as parameter $1
#/bin/sh
#name vg
vi.exe  $(grep -isl $1 *) &

# some variations
alias -x vp='vi `l\s -t *.@(pl|cgi)| head -1 `'

#execute the most recent script (I call this from within VIM with a mapped button)
alias -x xew='`l\s -t *.pl | head -1 `'

Cheers zzapper
%
When the screen has scrolled such as during a search, it may be difficult to
find the cursor.  :help %# explains the pattern one can use to highlight the
word around the cursor, which gives a bigger target to look for on the screen.
I have this in my .vimrc:

function VIMRCWhere()
    if !exists("s:highlightcursor")
        match Todo /\k*\%#\k*/
        let s:highlightcursor=1
    else
        match None
        unlet s:highlightcursor
    endif
endfunction
map <C-K> :call VIMRCWhere()<CR>

This means that in "normal" mode ctrl-k will toggle the highlight.  Todo is a
hightlight group whch is particularly easy to see.
For further information see ":help s:", ":help match",  ":help exists()"  and
":help funtion".
%
First, thanks for the script printascii.vim.

When looking at the ascii table, I found some characters I'd like to have
inserted when editing.
Add the following lines in your _gvimrc and you can select them via menu.
(change the names of the menu if you don't have German installed or don't like
my titles).
I also made some abbreviations to get separation lines in documentation or code
files,
e.g.
abb dotlin ^M
abb cdotlin /**/^M
abb fdotlin ^M
abb cfdotlin /**/^M
abb dlin =======================================================================^M
abb cdlin /*===================================================================*/^M
abb lin -----------------------------------------------------------------------^M
abb clin /*-------------------------------------------------------------------*/^M
abb ulin _______________________________________________________________________^M
abb culin /*___________________________________________________________________*/^M
abb Ulin ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯^M
abb cUlin /*¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯*/^M

(you have to substitute ^M with CTRL_V CTRL_M or delete it)

20imenu Editieren.Sonderzeichen.open\ angle\	«	<C-R>=nr2char(171)<CR>
20nmenu Editieren.Sonderzeichen.open\ angle\	«	a<C-R>=nr2char(171)<CR><ESC>
20imenu Editieren.Sonderzeichen.close\ angle\	»	<C-R>=nr2char(187)<CR>
20nmenu Editieren.Sonderzeichen.close\ angle\	»	a<C-R>=nr2char(187)<CR><ESC>
20imenu Editieren.Sonderzeichen.start\ mark\		<C-R>=nr2char(132)<CR>
20nmenu Editieren.Sonderzeichen.start\ mark\	 	a<C-R>=nr2char(132)<CR><ESC>
20imenu Editieren.Sonderzeichen.end\ mark\	\		<C-R>=nr2char(148)<CR>
20nmenu Editieren.Sonderzeichen.end\ mark\	\	 	a<C-R>=nr2char(148)<CR><ESC>
20imenu Editieren.Sonderzeichen.fat\ dot\	\		<C-R>=nr2char(149)<CR>
20nmenu Editieren.Sonderzeichen.fat\ dot\	\		a<C-R>=nr2char(149)<CR><ESC>
20imenu Editieren.Sonderzeichen.etc\	\	\		<C-R>=nr2char(133)<CR>
20nmenu Editieren.Sonderzeichen.etc\	\	\	 	a<C-R>=nr2char(133)<CR><ESC>
20imenu Editieren.Sonderzeichen.!underscore\	\	¯	<C-R>=nr2char(175)<CR>
20nmenu Editieren.Sonderzeichen.!underscore\	\	¯ 	a<C-R>=nr2char(175)<CR><ESC>
20imenu Editieren.Sonderzeichen.copyright\	\	©	<C-R>=nr2char(169)<CR>
20nmenu Editieren.Sonderzeichen.copyright\	\	©	a<C-R>=nr2char(169)<CR><ESC>
20imenu Editieren.Sonderzeichen.paragraph\	\	§	<C-R>=nr2char(167)<CR>
20nmenu Editieren.Sonderzeichen.paragraph\	\	§	a<C-R>=nr2char(167)<CR><ESC>
20imenu Editieren.Sonderzeichen.noitamalcxe\	¡	<C-R>=nr2char(161)<CR>
20nmenu Editieren.Sonderzeichen.noitamalcxe\	¡	a<C-R>=nr2char(161)<CR><ESC>
%
This is just in case there's somebody else who likes to work in a maximized vim
window on a high resolution desktop. If you follow good coding practice and
make sure your programs use only 80 characters in each row, have you noticed
how much space lies unused on the right?

I find that the following settings keep me from ever seeing another horizontal
split, unless I specifically ask for it.

cabbrev split vsplit
cabbrev hsplit split
cabbrev sta vertical sta
cabbrev help vertical help
cabbrev new vnew
cabbrev right botright

; A more heavyweight solution for ^W^]
function! ToggleSplit (dir)
    let currFname = bufname ("%")
    let old = winnr ()

    " Window navigation to ensure the correct window is 'last'.
    if (a:dir == "u")
        wincmd k
        let back="j"
    elseif (a:dir == "d")
        wincmd j
        let back="k"
    elseif (a:dir == "l") 
        wincmd h
        let back="l"
    elseif (a:dir == "r")
        wincmd l
        let back="h"
    endif

    if (winnr () == old)
        echo "Ouch"
        return
    endif

    exec "wincmd " . back

    quit

    if (back == "j" || back == "k")
        let orientation = "vsplit"
    else
        let orientation = "split"
    endif

    if (back == "j" || back == "l")
        let dir = "below"
    else
        let dir = "above"
    endif

    exec dir . " " . orientation " " . currFname
endfunction
noremap ^W^] ^W^]:silent call ToggleSplit ("d")<CR>

; Optional.
set splitright
; In which case the above mapping becomes:
noremap ^W^] :set splitbelow<CR>^W^]:silent call ToggleSplit ("u")<CR>:set
nosplitbelow<CR>
; Or you could just
set splitbelow
; :-)

; Very elegant and almost perfect, but it screws up if you want to run a
command with ranges :-)
;noremap : :vertical<Space>

; EOF
%
I use the following code in my plugins dir to ease session persistance. If I
want my session to persist I use :mks! and then whenever I open the Session.vim
file, my session is restored. If I am working from a restored session and I
close VIM, the session is saved automatically. Drawback is that it makes
editing the Session.vim file a bit cumbersome ;)

  au BufRead Session.vim so %
  au VimLeave * call SaveCurrentSession()

  function! SaveCurrentSession()
    if v:this_session != ""
      exe "mksession! " . v:this_session
    endif
  endfunction
%
You can make Vim scroll the text using the shifted up/down arrows, sort of like
your browser (except with shifted keys :), by mapping Shift-Up to Ctrl-Y and
Shift-Down to Ctrl-E.

    map <s-Down> <C-E>
    map <s-Up> <C-Y>

Shift-Down will then scroll down (like moving a scroll-bar down, or like moving
a cursor at the bottom of a window down), and Shift-Up will then scroll up
(like moving a scroll-bar up, etc).

If you'd rather think about the text moving down/up instead of the cursor
moving up/down, you can of course swap the mappings.

If you normally use j and k for cursor movement, and rarely use the arrow keys,
you can map the arrow keys directly, in which case I'd probably map the shifted
arrow keys back to cursor movement:

    map <down> <c-e>
    map <up> <c-y>
    map <s-down> j
    map <s-up> k

See :help ctrl-e, :help ctrl-y, and :help key-mapping.

See also :help i_ctrl-o and :help map-modes for how to set up these mappings
for use in other modes (like insert mode :).

(Vim by default maps s-Down and s-Up to Ctrl-F and Ctrl-B, for both normal and
visual mode.  Keep this in mind if you change some of the above mappings to
"nmap", 'cause you'll probably also want to look in to "vmap".)
%
Xemacs has a hide all function which can make all the function in your C file a
fold and close them. And here is something small to achieve similiar under Vim.

func! HideAll()
   syn region myFold start="{" end="}" transparent fold
   syn sync fromstart
   set foldnestmax=1
   set foldmethod=syntax
endfunc

amenu Whatever.Hide\ all :call HideAll()<CR>
%
I wanted to start using folding without having to get used to
seeing the (default) markers, a.k.a {{{ and }}}. So, here are 
2 autocmd's that will make them fade to black....bg=black fg=black

au BufRead,BufNewfile   * syn match fmrkr '"*{{{\|"*}}}'                 | 
                        \ syn cluster vimCommentGroup contains=fmrkr     | 
                        \ hi fmrkr term=NONE guibg=black   guifg=black 
                        \                    ctermbg=black ctermfg=black

au BufRead,BufNewfile   * syn match fmrkr '"*{{{\|"*}}}'
                        \ containedin=vimLineComment contained           | 
                        \ hi fmrkr term=NONE guibg=black   guifg=black
                        \                    ctermbg=black ctermfg=black

They both accomplish the same thing, but with different methods, so
simply pick one and see those annoying (at least to me) markers fade away.
I just tried it out with vim files, but you can easily modify it for
any other filetypes.

Thanks to Colin's lead with ':help c-syntax'    for the 1st au.
Thanks to Benji's lead with ':help containedin' for the 2nd au.
Understanding most of the syntax.txt document file would also be helpful.

To figure out what highlighting group the Marker is in, I would suggest
using Chip's vimtip#99.

Happy Vimming!
%
One of the most uncelebrated feature of vim 6.0 is the ability to span a search
across multiple lines.

\_^   maps a begining of line anywhere in search pattern. 
\_$   ---"----- end           ----------------------"-------------------------.
\_s  ---"------ space                   ------------"------------------------- .

e.g  /{\_s will map all white spaces and new-line chars after a "{"

The \_ can be appended to other objects as well. such as \_U,  \_L,  \_. (this
one's risky) .

See :help pattern for more details.
Njoy 
%
We're trying to develop txt2pdf.vim
http://vim.sourceforge.net/scripts/script.php?script_id=283 on Win.
It's a very simple module to save the current file and convert it to PDF using
our txt2pdf tool http://www.sanface.com/txt2pdf.html
On our Windows 2000 we've developed it. It works good.
Today we've tested the module on Linux. Surprise: it doesn't work.
Default Win Vim configure save on Win text in Win way: EOL \r\n.
A Vim module made in this way can't work on Linux (probably on every Unix OS).
If you want to make a Vim module on Win and you want it can work also on Unix
(we hope the same rula can work also on different OS) you've to save the Vim
module with Unix EOL (\n).

Please send us (sanface@sanface.com) your notes about other OS (e.g. OpenVMS).
%
     When things go wrong, it is sometimes hard to figure out why.  For example,
an option might be set in the system vimrc file, in a personal vimrc file, in a
plugin (global or local), or interactively.  Vim will tell you where the current
value was set if you ask:

:verbose set history?

will tell you the current value of the 'history' option, and where it was set.
%
Here are the main options you will want to set if you want to work with Unicode
files in (g)vim (see at bottom what help tags to look for)

if has("multi_byte")
	 set encoding=utf-8                       " how vim shall represent
	 characters internally
	 setglobal fileencoding=utf-8         " empty is also OK (defaults to same
	 as 'encoding'). Or you may want to set one of the ucs encodings (which
														  " may use less disk
														  space if you use only
														  "alphabetic" scripts
														  such as Latin, Greek,
														  Cyrillic, Hebrew or
														  Arabic, and
														  " not "ideographic"
														  scripts like Chinese,
														  Japanese or Korean.
														  With the ucs
														  encodings it is
														  usually better
	 set bomb                                      "  to also set 'bomb' on
	 ('byte-order-mark" option, irrelevant for utf-8 but not for ucs)
	 set termencoding=iso-8859-15    " or whatever is appropriate to your
	 locale (iso-8859-15 is Latin1 + Euro currency sign)
     set fileencodings=ucs-bom,iso-8859-15,iso-8859-3,utf-8
         " or whatever is appropriate to the kinds of files you want to edit
		 " 'fileencodings' defines the heuristic to set 'fillencoding' (local
		 to buffer) when reading an existing file. The first one that matches
		 will be used.
		 " ucs-bom is "ucs with byte-order-mark"; it must not come after ucs-8
		 if you want it to be used
else
     echoerr "Sorry, this version of (g)vim was not compiled with +multi_byte"
endif

In "replace" mode, one utf character (one or more data bytes) replaces one utf
character (which need not use the same number of bytes)
In "normal" mode, ga shows the character under the cursor as text, decimal,
octal and hex; g8 shows which byte(s) is/are used to represent it
In "insert" or "replace" mode,
  - any character defined on your keyboard can be entered the usual way (even
	with dead keys if you have them, e.g. âêîôû  äëïöü)
  - any character which has a "digraph" (there are a huge lot of them, see :dig
	after setting enc=utf-8) can be entered with a Ctrl-K prefix
  - any utf character at all can be entered with a Ctrl-V prefix, either
	<Ctrl-V> u aaaa or <Ctrl-V> U bbbbbbbb, with 0 <= aaaa <= FFFF, or 0 <=
	bbbbbbbb <= 7FFFFFFF

Unicode can be used to create html "body text", at least for Netscape 6 and
probably for IE; but on my machine it doesn't display properly as "title text"
(i.e., between <title></title> tags in the <head> part).

Gvim will display it properly if you have the fonts for it, provided that you
set 'guifont' to some fixed-width font which has the glyphs you want to use
(Courier New is OK for French, German, Greek, Russian and more, but I'm not
sure about Hebrew or Arabic; its glyphs are of a more "fixed" width than those
of, e.g. Lucida Console: the latter can be annoying if you need bold Cyrillic
writing).

see:

:h utf8
:h 'enc'
:h 'fenc'
:h 'fencs'
:h 'tenc'
:h 'bomb'
:h 'guifont'
:h ga
:h g8
:h i_Ctrl-V_digit

Happy Vimming !
Tony.
%
1. Where to look for help
-------------------------
:h utf8
:h encoding-values
:h 'enc'
:h 'fenc'
:h 'fencs'
:h 'tenc'
:h 'bomb'
:h 'guifont'
:h ga
:h g8
:h :dig
:h i_Ctrl-V_digit
:h has()

2. What to do (These are *examples*. Modify them to suit your work environment.)
-------------
if has("multi_byte")
     set encoding=utf-8
     setglobal fileencoding=utf-8
     set bomb
     set termencoding=iso-8859-15
     set fileencodings=ucs-bom,iso-8859-15,iso-8859-3,utf-8
else
     echoerr "Sorry, this version of (g)vim was not compiled with +multi_byte"
endif

3. What the above does
----------------------
* has("multi_byte") checks if you have the right options compiled-in. If you
* haven't got what it takes, it's no use trying to use Unicode.

* 'encoding' sets how vim shall represent characters internally. Utf-8 is
* necessary for most flavors of Unicode.

* 'fileencoding' sets the encoding for a particular file (local to buffer);
* :setglobal sets the default value. An empty value can also be used: it
* defaults to same as 'encoding'. Or you may want to set one of the ucs
* encodings, It might make the same disk file bigger or smaller depending on
* your particular mix of characters. Also, IIUC, utf-8 is always big-endian
* (high bit first) while ucs can be big-endian or little-endian, so if you use
* it, you will probably need to set 'bomb" (see below).

* 'bomb' (boolean): if set, vim will put a "byte order mark" at the start of
* ucs files. This option is irrelevant for most non-ucs files (utf-8, iso-8859,
* etc.)

* 'termencoding' defines how your keyboard encodes what you type. The value you
* put there will depend on your locale: iso-8859-15 is Latin1 + Euro currency
* sign, but you may want something else for, say, an Eastern European keyboard.

* 'fileencodings' defines the heuristic to set 'fileencoding' (local to buffer)
* when reading an existing file. The first one that matches will be used (and,
* IIUC, if there is no match, Vim falls back on Latin1). Ucs-bom is "ucs with
* byte-order-mark"; it must not come after utf-8 if you want it to be used.

4. Additional remarks
---------------------
* In "replace" mode, one utf character (one or more data bytes) replaces one
* utf character (which need not use the same number of bytes)

* In "normal" mode, ga shows the character under the cursor as text, decimal,
* octal and hex; g8 shows which byte(s) is/are used to represent it.

* In "insert" or "replace" mode,
  - any character defined on your keyboard can be entered the usual way (even
	with dead keys if you have them, e.g. French circumflex, German umlaut,
	etc.);
  - any character which has a "digraph" (there are a huge lot of them, see :dig
	after setting enc=utf-8) can be entered with a Ctrl-K prefix;
  - any utf character at all can be entered with a Ctrl-V prefix, either
	<Ctrl-V> u aaaa or <Ctrl-V> U bbbbbbbb, with 0 <= aaaa <= FFFF, or 0 <=
	bbbbbbbb <= 7FFFFFFF.

* Unicode can be used to create html "body text", at least for Netscape 6 and
* probably for IE; but on my machine it doesn't display properly as "title
* text" (i.e., between <title></title> tags in the <head> part).

* Gvim will display it properly if you have the fonts for it, provided that you
* set 'guifont' to some fixed-width font which has the glyphs you want to use
* (Courier New is OK for French, German, Greek, Russian and more, but I'm not
* sure about Hebrew or Arabic; its glyphs are of a more "fixed" width than
* those of, e.g. Lucida Console: the latter can be awkward if you need bold
* Cyrillic writing).

Happy Vimming !
Tony.
